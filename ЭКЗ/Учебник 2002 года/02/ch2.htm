<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
<TITLE>Лекция 2</TITLE>
</HEAD>
<BODY bgcolor="#FFFFFF">
<h3 align="center"><B><FONT FACE="Times New Roman"> <font size="6">Часть II. Процессы 
  и их поддержка в операционной системе </font></FONT></B></h3>
<P ALIGN="CENTER"> 
<P ALIGN="CENTER"><B> </B></P>
<P ALIGN="CENTER"><B><font face="Times New Roman" size="4">Глава 2. Процессы</font></B></P>
  <P align="center"><a href="../01/ch1.htm"> Предыдущая глава</a> | <a href="../os.html">Программа курса</a> | 
 <a href="../03/ch3.htm"> Следующая глава</a></P>
<p ALIGN="right"><font size="2"><i><font face="Courier New, Courier, mono">— Гусар, 
  Вы любите детей?<br>
  —  Нет. Но сам процесс!..&nbsp<br>
  Из известного   анекдота</font></I></font></P>
<P ALIGN="JUSTIFY"><font face="Times New Roman" size="3">Начиная с этой главы, 
  мы будем знакомиться с внутренним поведением операционных систем, разбирая одну 
  за другой их основные функции по отдельности и во взаимосвязи. Фундаментальным 
  понятием для изучения работы операционных систем является понятие <I>процессов</I>, 
  как основных динамических объектов, над которыми системы выполняют определенные 
  действия. Данная глава посвящена описанию таких объектов, их состояний и свойств, 
  их представлению в вычислительных системах, а также операциям, которые могут 
  проводиться над ними.</font></P>
 
<p align="center"><font size="3"><B><font face="Times New Roman"><a name="l0201">2.1. Понятие 
  процесса</a></font></B></font></p>

  <P  ALIGN="JUSTIFY"><font face="Times New Roman" size="3">В первой части книги мы, 
    поясняя понятие “операционная система” и описывая способы построения операционных 
    систем, часто применяли слова “программа” и “задание”. Мы писали: вычислительная 
    система исполняет одну или несколько программ, операционная система планирует 
    задания, программы могут обмениваться данными и&nbsp;т.&nbsp;д. Мы использовали 
    эти термины в некотором общеупотребительном, житейском смысле, предполагая, 
    что все читающие одинаково представляют себе, что собственно подразумевается 
    под ними в каждом конкретном случае. При этом одни и те же слова обозначали 
    и объекты в статическом состоянии, не обрабатывающиеся вычислительной системой 
    (например, совокупность файлов на диске), и объекты в динамическом состоянии, 
    находящиеся в процессе исполнения. Такой подход являлся справедливым, пока 
    мы говорили об общих свойствах операционных систем, не вдаваясь в подробности 
    их внутреннего поведения, или о работе вычислительных систем первого-второго 
    поколений, которые не могли обрабатывать более одной программы или одного 
    задания одновременно, по сути дела, не имея операционных систем. Как только 
    мы начинаем знакомиться с деталями функционирования современных компьютерных 
    систем, нам требуется уточнение терминологии.</font></P>
	
<P ALIGN="JUSTIFY"><font face="Times New Roman" size="3"> Рассмотрим следующий 
  пример. Допустим, что на жестком диске нашей вычислительной системы находится 
  подготовленная к исполнению программа вычисления квадратного корня из натуральных 
  чисел, и что два студента одновременно используют ее для обработки результатов 
  лабораторных работ. Одному из них требуется извлечь корень квадратный из 1, 
  а второму - из 4. С точки зрения студентов, они работают с одним и тем же объектом, 
  запуская на выполнение одну и ту же программу. С точки же зрения компьютерной 
  системы, она имеет дело с двумя различными вычислительными процессами. Разные 
  исходные данные обуславливают разные последовательности вычислений и приводят 
  к разным результатам, которые должны быть доставлены различным пользователям, 
  возможно, на различные устройства ввода-вывода. Было бы странным, если бы студент, 
  извлекающий квадратный корень из 1, получил в итоге значение 2, а студент, извлекающий 
  квадратный корень из 4 - значение 1. Следовательно, мы не можем использовать 
  термин "программа" в пользовательском смысле этого слова для описания того, 
  что происходит внутри вычислительной системы. </font></p>
  <P ALIGN="JUSTIFY"><font face="Times New Roman" size="3">Когда мы говорили о системах 
   пакетной обработки, мы ввели понятие “задание” как совокупности программы, набора 
  команд языка управления заданиями, необходимых для ее выполнения, и входных 
  данных. С точки зрения студентов, они, подставив разные исходные данные, сформировали 
  два различных задания. Может быть, термин “задание” подойдет нам для описания 
  внутреннего функционирования компьютерных систем? Чтобы выяснить это, давайте 
  рассмотрим другой пример. Пусть оба студента пытаются извлечь корень квадратный 
  из 1, то есть, пусть они сформировали идентичные задания</font><font size="3">,</font><font face="Times New Roman" size="3"> 
  но загрузили их в вычислительную систему со сдвигом по времени. В то время как 
  одно из выполняемых заданий приступило к печати полученного значения и ждет 
  окончания операции ввода-вывода, второе только начинает исполняться. Можем ли 
  мы сказать об идентичности заданий внутри вычислительной системы в данный момент 
  времени? Нет, так как состояние процесса их выполнения различно. Следовательно, 
  и слово “задание” в пользовательском смысле не может быть использовано для описания 
  происходящего в вычислительной системе.</font></P>
<P ALIGN="JUSTIFY"><font face="Times New Roman" size="3">Это происходит потому, 
  что термины “программа” и “задание” предназначены для описания статических, 
  неактивных объектов. Программа же в процессе исполнения является динамическим, 
  активным объектом. По ходу ее работы компьютер обрабатывает различные команды 
  и преобразует значения переменных. Для ее выполнения операционная система должна 
  выделить определенное количество оперативной памяти, закрепить за ней определенные 
  устройства ввода-вывода или файлы (откуда должны поступать входные данные и 
  куда нужно доставить полученные результаты), то есть зарезервировать определенные 
  ресурсы из общего числа ресурсов всей вычислительной системы. Их количество 
  и конфигурация могут изменяться с течением времени. Для описания таких активных 
  объектов внутри компьютерной системы вместо терминов “программа” и “задание” 
  мы будем использовать новый термин <I>“процесс”.</I></font> </P>
<P ALIGN="JUSTIFY"><font face="Times New Roman" size="3">В ряде учебных пособий 
  и монографий для простоты предлагается думать о процессе как об абстракции, 
  характеризующей выполняющуюся программу. С точки зрения авторов, эта рекомендация 
  является не совсем корректной. Понятие процесса характеризует некоторую совокупность 
  набора исполняющихся команд, ассоциированных с ним ресурсов (выделенная для 
  исполнения память или <I>адресное пространство</I>, стеки, используемые файлы 
  и устройства ввода-вывода и&nbsp;т.&nbsp;д.) и текущего момента его выполнения 
  (значения регистров, программного счетчика, состояние стека и значения переменных), 
  находящуюся под управлением операционной системы. Не существует взаимно однозначного 
  соответствия между процессами и программами, обрабатываемыми вычислительными 
  системами. Как будет показано в дальнейшем, в некоторых операционных системах 
  для работы определенных программ может организовываться более одного процесса 
  или один и тот же процесс может исполнять последовательно несколько различных 
  программ. Более того, даже в случае обработки только одной программы в рамках 
  одного процесса, нельзя считать, что процесс представляет собой просто динамическое 
  описание кода исполняемого файла, данных и выделенных для них ресурсов. Процесс 
  находится под управлением операционной системы и поэтому в нем может выполняться 
  часть кода ее ядра (не находящегося в исполняемом файле!), как в случаях, специально 
  запланированных авторами программы (например, при использовании системных вызовов), 
  так и в непредусмотренных ими ситуациях (например, при обработке внешних прерываний).</font></P>
<P ALIGN="center"><font size="3"><B><font face="Times New Roman"><a name="l0202">2.2. Состояния 
  процесса</a></font></B></font></P>
<P ALIGN="JUSTIFY"><font face="Times New Roman" size="3">При использовании такой 
  абстракции все, что выполняется в вычислительных системах (не только программы 
  пользователей, но и, возможно, определенные части операционных систем), организовано 
  как набор процессов. Понятно, что реально на однопроцессорной компьютерной системе 
  в каждый момент времени может исполняться только один процесс. Для мультипрограммных 
  вычислительных систем псевдопараллельная обработка нескольких процессов достигается 
  с помощью переключения процессора с одного процесса на другой. Пока один процесс 
  выполняется, остальные ждут своей очереди на получение процессора.</font></P>
<P ALIGN="JUSTIFY"><font face="Times New Roman" size="3">Как видим, каждый процесс 
  может находиться как минимум в двух состояниях: <B><I>процесс исполняется</i></B> 
  и <B><I>процесс не исполняется</i></B>. Диаграмма состояний процесса в такой 
  модели изображена на рисунке&nbsp;2.1.</font></P>
<P ALIGN="center"><img src="images/sr2-1.gif" width="562" height="131" align="absmiddle"></P>
<P ALIGN="center"><font size="3" face="Times New Roman, Times, serif">Рис 2.1. 
  Простейшая диаграмма состояний процесса.</font></P>
<P ALIGN="JUSTIFY"><font face="Times New Roman" size="3">Процесс, находящийся 
  в состоянии <i><b>процесс исполняется</b></i>, может через некоторое время завершиться 
  или быть приостановлен операционной системой и снова переведен в состояние <i><b>процесс 
  не исполняется</b></i>. Приостановка процесса происходит по одной из двух причин: 
  для его дальнейшей работы потребовалось возникновение какого-либо события (например, 
  завершения операции ввода-вывода) или истек временной интервал, отведенный операционной 
  системой для работы этого процесса. После этого операционная система по определенному 
  алгоритму выбирает для исполнения один из процессов, находящихся в состоянии 
  <i> <b>процесс не исполняется</b></i>, и переводит его в состояние <i><b>процесс 
  исполняется</b></i>. Новый процесс, появляющийся в системе, первоначально помещается 
  в состояние <i><b>процесс не исполняется</b></i>.</font></P>
<P ALIGN="center"><img src="images/sr2-2.gif" width="499" height="232"></P>
<P ALIGN="center"><font face="Times New Roman, Times, serif">Рис. 2.2. Более подробная 
  диаграмма состояний процесса.</font></P>
<P ALIGN="JUSTIFY"><font face="Times New Roman, Times, serif">Такая модель является 
  очень грубой. Она не учитывает, в частности то, что процесс, выбранный для исполнения, 
  может все еще ждать события, из-за которого он был приостановлен, и реально 
  к выполнению не готов. Для того чтобы избежать такой ситуации, разобьем состояние 
  <b> <i>процесс не исполняется</i></b> на два новых состояния: <b><i>готовность</i></b> 
  и <i><b>ожидание</b></i> (см. рисунок 2.2).</font> </P>
<P ALIGN="JUSTIFY"><font face="Times New Roman" size="3">Всякий новый процесс, 
  появляющийся в системе, попадает в состояние <B><I>готовность</i></B>. Операционная 
  система, пользуясь каким-либо алгоритмом планирования, выбирает один из готовых 
  процессов и переводит его в состояние <B><I>исполнение</i></B>. В состоянии 
  <B><I>исполнение</i></B> происходит непосредственное выполнение программного 
  кода процесса. Покинуть это состояние процесс может по трем причинам:</font></P>
<UL>
    <LI><font face="Times New Roman" size="3">либо он заканчивает свою деятельность;</font></LI>
    <LI><font face="Times New Roman" size="3">либо он не может продолжать свою работу, 
    пока не произойдет некоторое событие, и операционная система переводит его 
    в состояние <B><I>ожидание</i></B></font><font size="3">;</font></LI>
   <LI><font face="Times New Roman" size="3">либо в результате возникновения прерывания 
    в вычислительной системе (например, прерывания от таймера по истечении дозволенного 
    времени выполнения) его возвращают в состояние <B><I>готовность</i></B></font><font size="3">.</font></LI>
</UL>
<P ALIGN="JUSTIFY"> <font face="Times New Roman" size="3">Наша новая модель хорошо 
  описывает поведение процессов во время их жизни, но она не акцентирует внимания 
  на появлении процесса в системе и его исчезновении из системы. Для полноты картины 
  нам необходимо ввести еще два состояния процессов: <B><I>рождение</i></B></font><font size="3"> 
  <B><FONT FACE="Times New Roman">и <I>закончил исполнение</i></font></B><FONT FACE="Times New Roman"> 
  (см. рисунок&nbsp;2.3). </font></font></P>
<P ALIGN="center"><img src="images/sr2-3.gif" width="514" height="375"></P>
<P ALIGN="center"><font face="Times New Roman, Times, serif">Рис. 2.3. Диаграмма 
  состояний процесса, принятая в курсе.</font></P>
<P ALIGN="JUSTIFY"><font face="Times New Roman" size="3">Теперь для появления 
  в вычислительной системе процесс должен пройти через состояние <B><I>рождение</i></B>. 
  При рождении процесс получает в свое распоряжение адресное пространство, в которое 
  загружается программный код процесса; ему выделяются стек и системные ресурсы; 
  устанавливается начальное значение программного счетчика этого процесса и&nbsp;т.&nbsp;д. 
  Родившийся процесс переводится в состояние <B><I>готовность</i></B></font><font size="3">.</font><font face="Times New Roman" size="3"> 
  При завершении своей деятельности процесс из состояния <B><I>исполнение</i></B> 
  попадает в состояние <B><I>закончил исполнение</i></B></font><font size="3">. 
  </font></P>
<P ALIGN="JUSTIFY"><font face="Times New Roman" size="3">В конкретных операционных 
  системах состояния процесса могут быть еще более детализированы, могут появиться 
  некоторые новые варианты переходов из состояния в состояние. Так, например, 
  модель состояний процессов для операционной системы </font><font size="3">Windows 
  NT</font><font face="Times New Roman" size="3"> содержит 7 различных состояний, 
  а для операционной системы </font><font size="3">UNIX</font><font face="Times New Roman" size="3"> 
  — 9. Тем не менее, в принципе, все операционные системы подчиняются изложенной 
  выше модели.</font> </P>
<p align="center"><B><font face="Times New Roman" size="3"><a name="l0203">2.3. Операции над процессами 
  и связанные с ними понятия</a></font></B></p>
<p align="center"><font size="3"><B><FONT FACE="Times New Roman"><a name="l020301">2.3.1. Набор 
  операций</a ></FONT></B></font></p>
<P ALIGN="JUSTIFY"><font face="Times New Roman" size="3">Процесс не может сам 
  перейти из одного состояния в другое. Изменением состояния процессов занимается 
  операционная система, совершая операции над ними. Количество таких операций 
  в нашей модели пока совпадает с количеством стрелок на диаграмме состояний. 
  Удобно объединить их в три пары:</font></P>
<UL>
  <LI><font face="Times New Roman" size="3">Создание процесса — завершение процесса;</font></LI>
  <LI><font face="Times New Roman" size="3">Приостановка процесса (перевод из 
    состояния <B><I>исполнение</i></B> в состояние <B><I>готовность</i></B>) — 
    запуск процесса (перевод из состояния <B><I>готовность</i></B> в состояние 
    <B><I>исполнение</i></B></font><font size="3">);</font></LI>
  <LI><font face="Times New Roman" size="3">Блокирование процесса (перевод из 
    состояния <B><I>исполнение</i></B> в состояние <B><I>ожидание</i></B>) — разблокирование 
    процесса (перевод из состояния <B><I>ожидание</i></B> в состояние <B><I>готовность</i></B></font><font size="3">);</font></LI>
</UL>
<P ALIGN="JUSTIFY"><font face="Times New Roman" size="3">В дальнейшем, когда <a href="../03/ch3.htm#l0305">мы 
  будем говорить об алгоритмах планирования</a>, в нашей модели появится еще одна 
  операция, не имеющая парной: изменение приоритета процесса.</font></P>
<P ALIGN="JUSTIFY"><font face="Times New Roman" size="3">Операции создания и завершения 
  процесса являются одноразовыми, так как применяются к процессу не более одного 
  раза (некоторые системные процессы никогда не завершаются при работе вычислительной 
  системы). Все остальные операции, связанные с изменением состояния процессов, 
  будь то запуск или блокировка, как правило, являются многоразовыми. Рассмотрим 
  подробнее, как операционная система выполняет операции над процессами.</font></P>
<p align="center"><font size="3" face="Times New Roman, Times, serif"><B><a name="l020302">2.3.2. 
  Process Control Block и контекст процесса</a></b></font></p>
<P ALIGN="JUSTIFY"><font face="Times New Roman" size="3">Для того чтобы операционная 
  система могла выполнять операции над процессами, каждый процесс представляется 
  в ней некоторой структурой данных. Эта структура содержит информацию, специфическую 
  для данного процесса: </font></P>
<UL>
  <LI><font face="Times New Roman" size="3">состояние, в котором находится процесс;</font></LI>
  <LI><font face="Times New Roman" size="3">программный счетчик процесса или, 
    другими словами, адрес команды, которая должна быть выполнена для него следующей;</font></LI>
  <LI><font face="Times New Roman" size="3">содержимое регистров процессора;</font></LI>
  <LI><font face="Times New Roman" size="3">данные, необходимые для планирования 
    использования процессора и управления памятью (приоритет процесса, размер 
    и расположение адресного пространства и&nbsp;т.&nbsp;д.);</font></LI>
  <LI><font face="Times New Roman" size="3">учетные данные (идентификационный 
    номер процесса, какой пользователь инициировал его работу, общее время использования 
    процессора данным процессом и&nbsp;т.&nbsp;д.);</font></LI>
  <LI><font face="Times New Roman" size="3">информацию об устройствах ввода-вывода, 
    связанных с процессом (например, какие устройства закреплены за процессом, 
    таблицу открытых файлов);</font></LI>
</UL>
<P ALIGN="JUSTIFY"><font face="Times New Roman" size="3">Конкретный ее состав 
  и строение зависят, конечно, от конкретной операционной системы. Во многих операционных 
  системах информация, характеризующая процесс, хранится не в одной, а в нескольких 
  связанных структурах данных. Эти структуры могут иметь различные наименования, 
  содержать дополнительную информацию или, наоборот, лишь часть описанной информации. 
  Для нас это не имеет значения. Для нас важно лишь то, что для любого процесса, 
  находящегося в вычислительной системе, вся информация, необходимая для совершения 
  операций над ним, доступна операционной системе</font><font size="3">. </font><font face="Times New Roman" size="3">Для 
  простоты изложения будем считать, что она хранится в одной структуре данных. 
  Мы будем называть ее </font><font size="3">PCB (Process Control Block)</font><font face="Times New Roman" size="3"> 
  или блоком управления процессом. Блок управления процессом является моделью 
  процесса для операционной системы. Любая операция, производимая операционной 
  системой над процессом, вызывает определенные изменения в </font><font size="3">PCB</font><font face="Times New Roman" size="3">. 
  В рамках принятой модели состояний процессов содержимое </font><font size="3">PCB</font><font face="Times New Roman" size="3"> 
  между операциями остается постоянным.</font></P>
<P ALIGN="JUSTIFY"><font face="Times New Roman" size="3">Информацию, для хранения 
  которой предназначен блок управления процессом, удобно для дальнейшего изложения 
  разделить на две части. Содержимое всех регистров процессора (включая значение 
  программного счетчика) будем называть <I>регистровым контекстом</I> процесса, 
  а все остальное – <I>системным контекстом</I> процесса. Знания регистрового 
  и системного контекстов процесса достаточно для того, чтобы управлять его поведением 
  в операционной системе, совершая над ним операции. Однако этого недостаточно, 
  чтобы полностью характеризовать процесс. Операционную систему не интересует, 
  какими именно вычислениями занимается процесс, т.&nbsp;е. какой код и какие 
  данные находятся в его адресном пространстве. С точки зрения пользователя, наоборот, 
  наибольший интерес представляет содержимое адресного пространства процесса, 
  возможно наряду с регистровым контекстом, определяющее последовательность преобразования 
  данных и полученные результаты. Код и данные, находящиеся в адресном пространстве 
  процесса, будем называть его <I>пользовательским контекстом</I>. Совокупность 
  регистрового, системного и пользовательского контекстов процесса для краткости 
  принято называть просто <I>контекстом</I> процесса. В любой момент времени процесс 
  полностью характеризуется своим контекстом.</font></P>
<p align="center"><font size="3"><B><FONT FACE="Times New Roman"><a name="l020303">2.3.3. Одноразовые 
  операции</a></FONT></B></font></p>
<P ALIGN="JUSTIFY"><font face="Times New Roman, Times, serif">Сложный жизненный 
  путь процесса в компьютере начинается с его рождения. Любая операционная система, 
  поддерживающая концепцию процессов, должна обладать средствами для их создания. 
  В очень простых системах (например, в системах, спроектированных для работы 
  только одного конкретного приложения) все процессы могут быть порождены на этапе 
  старта системы. Более сложные операционные системы создают процессы динамически, 
  по мере необходимости. Инициатором рождения нового процесса после старта операционной 
  системы может выступить либо процесс пользователя, совершивший специальный системный 
  вызов, либо сама операционная система, то есть, в конечном итоге, тоже некоторый 
  процесс. Процесс, инициировавший создание нового процесса, принято называть 
  процессом-родителем (parent process), а вновь созданный процесс - процессом-ребенком 
  (child process). Процессы-дети могут, в свою очередь, порождать новых детей 
  и т. д., образуя, в общем случае, внутри системы набор генеалогических деревьев 
  процессов - генеалогический лес. Пример генеалогического леса изображен на рисунке 
  2.4. Следует отметить, что все пользовательские процессы вместе с некоторыми 
  процессами операционной системы принадлежат к одному и тому же дереву леса. 
  В ряде вычислительных систем лес вообще вырождается в одно такое дерево. </font></P>
<P ALIGN="center"><img src="images/sr2-4.gif" width="688" height="240"></P>
<P ALIGN="center"><font face="Times New Roman, Times, serif">Рис 2.4 Упрощенный 
  генеалогический лес процессов. Стрелочка означает отношение родитель-ребенок.</font></P>
<P ALIGN="JUSTIFY"><font face="Times New Roman" size="3"><a name="l020303a"></a>При рождении процесса 
  система заводит новый </font><font size="3">PCB </font><font face="Times New Roman" size="3">с 
  состоянием процесса <B><I>рождение</i></B> и начинает его заполнение. Новый 
  процесс получает свой собственный уникальный идентификационный номер. Поскольку 
  для хранения идентификационного номера процесса в операционной системе отводится 
  ограниченное количество бит, то для соблюдения уникальности номеров количество 
  одновременно присутствующих в ней процессов должно быть ограничено. После завершения 
  какого-либо процесса его освободившийся идентификационный номер может быть повторно 
  использован для другого процесса.</font></P>
<P ALIGN="JUSTIFY"><font face="Times New Roman, Times, serif">Обычно для выполнения 
  своих функций процесс-ребенок требует определенных ресурсов: памяти, файлов, 
  устройств ввода-вывода и т. д. Существует два подхода к их выделению. Новый 
  процесс может получить в свое пользование некоторую часть родительских ресурсов, 
  возможно, разделяя с процессом-родителем и другими процессами-детьми права на 
  них, подобно распределению ресурсов в нормальной человеческой семье, или может 
  получить свои ресурсы непосредственно от операционной системы, став, так сказать, 
  на государственное обеспечение в детдоме. Информация о выделенных ресурсах заносится 
  в PCB. </font></P>
<P ALIGN="JUSTIFY"><font face="Times New Roman" size="3"><a name="l020303b"></a>После 
  наделения процесса-ребенка ресурсами необходимо занести в его адресное пространство 
  программный код, значения данных, установить программный счетчик. Здесь также 
  возможны два решения. В первом случае процесс-ребенок становится дубликатом 
  процесса-родителя по регистровому и пользовательскому контекстам, при этом должен 
  существовать способ определения кто для кого из процессов-двойников является 
  родителем. Во втором случае процесс-ребенок загружается новой программой из 
  какого-либо файла. <a href="../03/prep/sem3-4.htm#s0307"><img border="0" src="../images/computer.gif" align="right" alt="Создание процессов в UNIX" vspace="3" width="48" height="48"></a> 
  Операционная система </font><font size="3">UNIX </font><font face="Times New Roman" size="3">разрешает 
  порождение процесса только первым способом; для запуска новой программы необходимо 
  сначала создать копию процесса-родителя, а затем процесс-ребенок должен заменить 
  свой пользовательский контекст с помощью специального системного вызова. Операционные 
  системы </font><font size="3">VAX/VMS </font><font face="Times New Roman" size="3">и 
  WINDOWS NT допускают только второе решение. </font></P>
  <P ALIGN="JUSTIFY"><font face="Times New Roman" size="3">Порождение нового процесса 
    как дубликата процесса-родителя приводит к возможности существования программ 
    (т.&nbsp;е. исполняемых файлов), для работы которых организуется более одного 
    процесса.<a href="../03/prep/sem3-4.htm#s0313"><img border="0" src="../images/computer.gif" align="right" alt="Запуск новой программы в UNIX" width="48" height="48"></a> Возможность замены пользовательского контекста процесса по ходу 
    его работы (т.&nbsp;е. загрузки для исполнения новой программы) приводит к 
    тому, что в рамках одного и того же процесса могут быть последовательно выполнены 
    несколько различных программ.</font></P>
  <P ALIGN="JUSTIFY"><font face="Times New Roman" size="3">После того как процесс 
    наделен содержанием, в </font><font size="3">PCB </font><font face="Times New Roman" size="3">дописывается 
    оставшаяся информация и состояние нового процесса изменяется на <B><I>готовность</i></B>. 
    Осталось сказать несколько слов о том, как ведут себя процессы-родители после 
    рождения процессов-детей. Процесс-родитель может продолжать свое выполнение 
    одновременно с выполнением процесса-ребенка, а может ожидать завершения работы 
    некоторых или всех своих детей. </font></P>
  <P ALIGN="JUSTIFY"><font face="Times New Roman" size="3"><a name="l020303c"></a>Мы не будем в деталях 
    останавливаться на причинах, которые могут привести к окончанию жизненного 
    цикла процесса. После того, как процесс завершил свою работу, операционная 
    система переводит его в состояние <B><I>закончил исполнение</i></B> и освобождает 
    все ассоциированные с ним ресурсы, делая соответствующие записи в блоке управления 
    процессом. При этом сам </font><font size="3">PCB</font><font face="Times New Roman" size="3"> 
    не уничтожается, а остается в системе еще некоторое время. Это связано с тем, 
    что процесс-родитель после завершения процесса-ребенка может запросить операционную 
    систему о причине произошедшей смерти порожденного им процесса и</font><font size="3">/</font><font face="Times New Roman" size="3">или 
    статистическую информацию об его работе. Подобная информация сохраняется в 
    </font><font size="3">PCB </font><font face="Times New Roman" size="3">мертвого 
    процесса до запроса процесса-родителя или до конца его деятельности, после 
    чего все следы умершего процесса окончательно исчезают из системы. В операционной 
    системе </font><font size="3">UNIX</font><font face="Times New Roman" size="3"> 
    процессы, находящиеся в состоянии <B><I>закончил исполнение</i></B>, принято 
    называть процессами зомби.</font></P>
<P ALIGN="JUSTIFY"><font face="Times New Roman" size="3">Следует заметить, что 
    в ряде операционных систем (например, в </font><font size="3">VAX/VMS) </font><font face="Times New Roman" size="3">гибель 
    процесса-родителя приводит к завершению работы всех его детей. В других операционных 
    системах (например, в </font><font size="3">UNIX) </font><font face="Times New Roman" size="3">процессы-дети 
    продолжают свое существование и после окончания работы процесса-родителя. 
    При этом возникает необходимость изменения информации в </font><font size="3">PCB 
    </font><font face="Times New Roman" size="3">процессов-детей о породившем 
    их процессе для того, чтобы генеалогический лес процессов оставался целостным. 
    Рассмотрим следующий пример. Пусть процесс с номером 2515 был порожден процессом 
    с номером 2001 и после завершения его работы остается в вычислительной системе 
    неограниченно долго. Тогда, не исключено, что номер 2001 будет использован 
    операционной системой повторно для совсем другого процесса. Если не изменить 
    информацию о процессе-родителе для процесса 2515, то генеалогический лес процессов 
    окажется некорректным — процесс 2515 будет считать своим родителем новый процесс 
    2001, а процесс 2001 будет открещиваться от нежданного потомка. Как правило, 
    осиротевшие процессы усыновляются одним из системных процессов, который порождается 
    при старте операционной системы, и функционирует все время, пока она работает.</font></P>
<P ALIGN="center"><font size="3"><B><FONT FACE="Times New Roman"><a name="l020304">2.3.4. Многоразовые 
  операции</a></FONT></B></font> 
<p ALIGN="JUSTIFY"><font face="Times New Roman, Times, serif">Одноразовые операции приводят к 
  изменению количества процессов, находящихся под управлением операционной системы, 
  и всегда связаны с выделением или освобождением определенных ресурсов. Многоразовые 
  операции, напротив, не приводят к изменению количества процессов в операционной 
  системе и не обязаны быть связанными с выделением или освобождением ресурсов.</font></p>
<P ALIGN="JUSTIFY"><font face="Times New Roman" size="3">В этом разделе мы кратко 
  опишем действия, которые производит операционная система при выполнении многоразовых 
  операций над процессами. Более тщательно эти действия будут рассмотрены далее 
  в соответствующих главах книги. </font>
<P ALIGN="JUSTIFY"><font face="Times New Roman" size="3"><B>Запуск процесса. </b>Из 
  числа процессов, находящихся в состоянии <B><I>готовность</i></B>, операционная 
  система выбирает один процесс для последующего исполнения. Критерии и алгоритмы 
  такого выбора будут подробно рассмотрены в главе&nbsp;<a href="../03/l3.htm">3 
  — “Планирование процессов”</a>. Для избранного процесса операционная система 
  обеспечивает наличие в оперативной памяти информации, необходимой для его дальнейшего 
  выполнения. То, как она это делает, будет в деталях описано в <a href="../08/ch8.htm">части&nbsp;III 
  — “Управление памятью”</a>. Далее состояние процесса изменяется на <B><I>исполнение</i></B>, 
  восстанавливаются значения регистров для данного процесса, и управление передается 
  команде, на которую указывает счетчик команд процесса. Все данные, необходимые 
  для этого восстановления контекста, извлекаются из </font><font size="3">PCB 
  </font><font face="Times New Roman" size="3">процесса, над которым совершается 
  операция.</font> 
<P ALIGN="JUSTIFY"><font face="Times New Roman" size="3"><B>Приостановка процесса. 
  </b>Работа процесса, находящегося в состоянии <B><I>исполнение</i></B>, приостанавливается 
  в результате какого-либо прерывания. Процессор автоматически сохраняет счетчик 
  команд и, возможно, один или несколько регистров в стеке исполняемого процесса 
  и передает управление по специальному адресу обработки данного прерывания. На 
  этом деятельность hardware по обработке прерывания завершается. По указанному 
  адресу обычно располагается одна из частей операционной системы. Она сохраняет 
  динамическую часть системного и регистрового контекстов процесса в его PCB, 
  переводит процесс в состояние <B><I>готовность</i></B> и приступает к обработке 
  прерывания, то есть к выполнению определенных действий, связанных с возникшим 
  прерыванием. </font>
<P ALIGN="JUSTIFY"><font face="Times New Roman" size="3"><B>Блокирование процесса. 
  </b>Процесс блокируется, когда он не может продолжать свою работу, не дождавшись 
  возникновения какого-либо события в вычислительной системе. Для этого он обращается 
  к операционной системе с помощью определенного системного вызова. Операционная 
  система обрабатывает системный вызов (инициализирует операцию ввода-вывода, 
  добавляет процесс в очередь процессов, дожидающихся освобождения устройства 
  или возникновения события, и&nbsp;т.&nbsp;д.) и, при необходимости, сохранив 
  необходимую часть контекста процесса в его </font><font size="3">PCB,</font><font face="Times New Roman" size="3"> 
  переводит процесс из состояния <B><I>исполнение</i></B> в состояние <B><I>ожидание</i></B>. 
  Подробнее эта операция будет рассматриваться в <a href="../13/ch13.htm">части&nbsp;V 
  — “Управление вводом-выводом”</a>.</font> 
<P ALIGN="JUSTIFY"><font face="Times New Roman" size="3"><B>Разблокирование процесса.</b> 
  После возникновения в системе какого-либо события, операционной системе нужно 
  точно определить какое именно событие произошло. Затем операционная система 
  проверяет: находился ли некоторый процесс в состоянии <B><I>ожидание</i></B> 
  для данного события и, если находился, переводит его в состояние <B><I>готовность</i></B>, 
  выполняя необходимые действия, связанные с наступлением события (инициализация 
  операции ввода-вывода для очередного ожидающего процесса и&nbsp;т.&nbsp;п.). 
  Эта операция, как и операция блокирование, будет детальнее описана <a href="../13/ch13.htm">в 
  части&nbsp;V — “Управление вводом-выводом”</a>.</font> 
<P ALIGN="center"><font size="3"><B><FONT FACE="Times New Roman"><a name="l020305">2.3.5. Переключение 
  контекста</a></FONT></B></font> 
<p  ALIGN="center"><font face="Times New Roman" size="3">До сих пор мы рассматривали 
  операции над процессами изолированно, независимо друг от друга. В действительности 
  же деятельность мультипрограммной операционной системы состоит из цепочек операций, 
  выполняемых над различными процессами, и сопровождается переключением процессора 
  с одного процесса на другой.<img src="images/sr2-5.gif" width="712" height="357"></font></P>
<p align="center">&nbsp;</P>
<p align="center"><font face="Times New Roman, Times, serif">Рис 2.5 Выполнение 
  операции разблокирования процесса. Использование термина &quot;код пользователя&quot; 
  не ограничивает общности рисунка только пользовательскими процессами</font></P>
<P ALIGN="JUSTIFY"><font face="Times New Roman, Times, serif">Давайте для примера 
  упрощенно рассмотрим, как в реальности может проистекать операция разблокирования 
  процесса, ожидающего ввода-вывода (см. рисунок 2.5). При исполнении процессором 
  некоторого процесса (на рисунке - процесс 1) возникает прерывание от устройства 
  ввода-вывода, сигнализирующее об окончании операций на устройстве. Над выполняющимся 
  процессом производится операция приостановка. Далее, операционная система разблокирует 
  процесс, инициировавший запрос на ввод-вывод (на рисунке - процесс 2), и осуществляет 
  запуск приостановленного или нового процесса, выбранного при выполнении планирования 
  (на рисунке был выбран разблокированный процесс). Как видим, в результате обработки 
  информации об окончании операции ввода-вывода возможна смена процесса, находящегося 
  в состоянии <i><b>исполнение</b></i>.</font>
<P ALIGN="JUSTIFY"><font face="Times New Roman" size="3">Для корректного переключения 
  процессора с одного процесса на другой необходимо сохранить контекст исполнявшегося 
  процесса и восстановить контекст процесса, на который будет переключен процессор. 
  Такая процедура сохранения/восстановления работоспособности процессов называется 
  <I>переключением контекста</I>. Время, затраченное на переключение контекста, 
  не используется вычислительной системой для совершения полезной работы и представляет 
  собой накладные расходы, снижающие производительность системы. Оно меняется 
  от машины к машине и обычно находится в диапазоне от 1 до 1000 микросекунд. 
  Существенно сократить накладные расходы в современных операционных системах 
  позволяет расширенная модель процессов, включающая в себя понятие </font><font size="3"><i><font face="Times New Roman, Times, serif">threads 
  of execution </font></i>(</font><font face="Times New Roman" size="3">нити исполнения 
  или просто нити). Подробнее о нитях исполнения мы будем говорить в <a href="../04/ch4.htm#l0404">главе&nbsp;4 
  — “Кооперация процессов и основные аспекты ее логической организации”</a>.</font> 
<P ALIGN="center"><font size="3"><B><FONT FACE="Times New Roman"><a name="l0204">2.4. Резюме</a></FONT></B></font>
<P ALIGN="JUSTIFY"><font face="Times New Roman" size="3"><a href="#l0201">Понятие 
  процесса </a>характеризует некоторую совокупность набора исполняющихся команд, 
  ассоциированных с ним ресурсов и текущего момента его выполнения, находящуюся 
  под управлением операционной системы. В любой момент времени процесс полностью 
  описывается своим <a href="#l020302">контекстом</a>, состоящим из регистровой, 
  системной и пользовательской частей. В операционной системе процессы представляются 
  определенной структурой данных — </font><font size="3"><a href="#l020302">PCB</a></font><font face="Times New Roman" size="3">, 
  отражающей содержание регистрового и системного контекстов</font><font size="3">. 
  </font><font face="Times New Roman" size="3">Процессы могут находиться в пяти 
  основных <a href="#l0202">состояниях</a>: <B><I>рождение</i></B></font><font size="3">, 
  <B><I><FONT FACE="Times New Roman">готовность</font></i></B>, <B><I><FONT FACE="Times New Roman">исполнение</font></i></B>, 
  <B><I><FONT FACE="Times New Roman">ожидание</font></i></B>, <B><I><FONT FACE="Times New Roman">закончил 
  исполнение</font></i></B><FONT FACE="Times New Roman">. Из состояния в состояние 
  процесс переводится операционной системой в результате выполнения над ним <a href="#l020301"> 
  операций</a>. Операционная система может выполнять над процессами следующие 
  операции: <a href="#l020303"> создание процесса, завершение процесса</a>, <a href="#l020304"> 
  приостановка процесса, запуск процесса, блокирование процесса, разблокирование 
  процесса</a>, изменение приоритета процесса. Между выполнением операций содержимое 
  </FONT>PCB</font><font face="Times New Roman" size="3"> не изменяется. Деятельность 
  мультипрограммной операционной системы состоит из цепочек перечисленных операций, 
  выполняемых над различными процессами, и сопровождается процедурами сохранения/восстановления 
  работоспособности процессов, т.&nbsp;е. <a href="#l020305"> переключением контекста</a>. 
  Переключение контекста не имеет отношения к полезной работе, выполняемой процессами, 
  и время, затраченное на него, уменьшает полезное время работы процессора.</font></P>
  
<P align="center"><a href="../01/ch1.htm"> Предыдущая глава</a> | <a href="../os.html">Программа 
  курса</a> | <a href="../03/ch3.htm"> Следующая глава</a></P><br>
  
</BODY>
</HTML>
