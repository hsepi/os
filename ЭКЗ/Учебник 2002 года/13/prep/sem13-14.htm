<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
<TITLE>Семинары 13-14</TITLE>
</HEAD>
  <BODY bgcolor="#FFFFFF">
  <basefont face="Times New Roman, sans-serif, Courier, mono" size="3">
  
  <P ALIGN="CENTER"><B><FONT face="Times New Roman, sans-serif, Courier, mono" SIZE = 6>Семинары 13-14. Организация 
        ввода-вывода в UNIX. Файлы устройств. 
        Аппарат прерываний. Сигналы в UNIX.</FONT></B></P>
<P ALIGN="CENTER">(Основываются на <a href="../../12/l12.htm">лекции 12</a> и <a href="../../13/l13.htm">лекции 13</a>) </P>
  
<P align="center"><a href="../../11/prep/sem11-12.htm"> Предыдущий семинар</a> 
  | <a href="../../os.html">Программа курса</a><a href="../../15/prep/sem15-16.htm"> Следующий семинар</a></P>

<FONT face="Times New Roman, sans-serif, Courier, mono" SIZE = 4>  <B><P ALIGN="CENTER">Программа семинара</P> </B></font>
<ol>
<li><a href="#s1301"> 
    <P ALIGN="JUSTIFY"><font face="Times New Roman, Times, serif" size="3">Понятие виртуальной файловой системы.  </font> 
    </a></li>
  <li><a href="#s1302"> 
    <P ALIGN="JUSTIFY"><font face="Times New Roman, Times, serif" size="3">Операции над файловыми системами. 
	Монтирование файловых систем. </font> 
    </a></li>
  <li><a href="#s1303"> 
    <P ALIGN="JUSTIFY"><font face="Times New Roman, Times, serif" size="3">Блочные, 
    символьные устройства. Понятие драйвера. Блочные, символьные драйверы, драйверы 
    низкого уровня. Файловый интерфейс.</font> 
    </a></li>
  <li><a href="#s1304"> 
    <P ALIGN="JUSTIFY"><font face="Times New Roman, Times, serif" size="3">Аппаратные прерывания (interrupt), 
    исключения (exception), 
    программные прерывания (trap, software interrupt). Их 
    обработка.</font> 
    </a></li>
  <li><a href="#s1305"> 
    <P ALIGN="JUSTIFY"><font face="Times New Roman, Times, serif" size="3">Понятие сигнала.
	 Способы возникновения сигналов и виды их обработки. 
	</font> 
    </a></li>
  <li><a href="#s1306"> 
    <P ALIGN="JUSTIFY"><font face="Times New Roman, Times, serif" size="3">Понятия 
      группы процессов, сеанса, лидера группы, лидера сеанса, управляющего терминала 
      сеанса. Системные вызовы getpgrp(), setpgrp(), getpgid(), setpgid(), getsid(), 
      setsid()</font> 
    </a></li>
  <li><a href="#s1307"> 
    <P ALIGN="JUSTIFY"><font face="Times New Roman, Times, serif" size="3"> Системный 
    вызов kill() и команда kill().</font> 
    </a>
  </li>
  <li><a href="#s1310"> 
    <P ALIGN="JUSTIFY"><font face="Times New Roman, Times, serif" size="3"> Системный вызов signal(). 
    Установка собственного обработчика сигнала.</font>
    </a>
	</li>
	<li><a href="#s1315"> 
    <P ALIGN="JUSTIFY"><font face="Times New Roman, Times, serif" size="3">
	Восстановление предыдущей реакции на сигнал. 
	</font> 
    </a></li>
  <LI><a href="#s1316"> <P ALIGN="JUSTIFY"><FONT face="Times New Roman, sans-serif, Courier, mono" size="3">Сигналы 
    SIGUSR1 и SIGUSR2. Использование сигналов для синхронизации процессов.</font></A></LI>
  <LI><a href="#s1317"> 
    <P ALIGN="JUSTIFY"><FONT face="Times New Roman, sans-serif, Courier, mono" size="3">Завершение порожденного процесса. Системный вызов waitpid(). 
      Сигнал SIGCHLD.</font>
    </A></LI>
	 <LI><a href="#s1319"> <P ALIGN="JUSTIFY">
  <FONT face="Times New Roman, sans-serif, Courier, mono" size="3">Возникновение
    сигнала SIGPIPE 
    при попытке записи в pipe или FIFO, 
    который никто не собирается читать.</font></A></LI>
	 <LI><a href="#s1320"> 
    <P ALIGN="JUSTIFY"> <FONT face="Times New Roman, sans-serif, Courier, mono" size="3">Понятие о надежности сигналов.
	  POSIX функции для работы с сигналами.</font>
    </A></LI> 	
	
   </ol>

<P align="center">
<font face="Times New Roman, Times, serif" size="3"><B><font size="4">Цели занятия</font></B></font> 
<OL>
  <LI><P ALIGN="JUSTIFY"><FONT face="Times New Roman, sans-serif, Courier, mono" size="3">Дать понятие об организации управлением 
    ввода-вывода в UNIX.</font></LI>
  <LI><P ALIGN="JUSTIFY"><FONT face="Times New Roman, sans-serif, Courier, mono" size="3">Объяснить, что такое файлы устройств 
    и для чего они нужны.</FONT></LI>
  <LI>
    <P ALIGN="JUSTIFY"><FONT face="Times New Roman, sans-serif, Courier, mono" size="3">Объяснить 
      иерархическую систему процессов в UNIX, как процесс может стать лидером 
      группы или лидером сеанса. </font>
  </LI>
  <LI><P ALIGN="JUSTIFY"><FONT face="Times New Roman, sans-serif, Courier, mono" size="3">Студент должен получить четкое осознание 
    отличия аппаратных прерываний, исключений и программных прерываний (interrupt, 
    exception, software interrupt или 
    trap).</font></LI>
  <LI><P ALIGN="JUSTIFY"><FONT face="Times New Roman, sans-serif, Courier, mono" size="3">Дать понятие об организации сигналов 
    в UNIX. </font></LI>
  
  <LI>
    <P ALIGN="JUSTIFY"><FONT face="Times New Roman, sans-serif, Courier, mono" size="3">Дать 
      навык работы с сигналами от терминала, порожденного процесса, для организации 
      синхронизации процессов.</FONT>
  </LI>
  <LI>
    <P ALIGN="JUSTIFY"><FONT face="Times New Roman, sans-serif, Courier, mono" size="3">Студент должен осознать степень надежности
	передачи информации процессу с использованием сигналов.</FONT>
  </LI>
</OL>
  <P ALIGN="CENTER"><font face="Times New Roman, Times, serif" size="4"><B>Практические 
  работы</B></font></P>
 <ol> 
  <LI><P ALIGN="JUSTIFY"><FONT face="Times New Roman, sans-serif, Courier, mono" size="3">
  <a href="#s1308">Изучение особенностей получения терминальных 
    сигналов текущей и фоновой группой процессов.</a></FONT></LI>
  <LI>
    <P ALIGN="JUSTIFY"><FONT face="Times New Roman, sans-serif, Courier, mono" size="3"> 
      <a href="#s1309">Изучение получения сигнала SIGHUP процессами при завершении 
      лидера сеанса.</a></font>
  </LI>
  <LI> <P ALIGN="JUSTIFY"><FONT face="Times New Roman, sans-serif, Courier, mono" size="3">
  <a href="#s1311">Прогон программы, игнорирующей сигнал 
    SIGINT.</a></font></LI>
  <LI> <P ALIGN="JUSTIFY"><FONT face="Times New Roman, sans-serif, Courier, mono" size="3">
  <a href="#s1312">Модификация предыдущей программы для игнорирования сигналов SIGINT и SIGQUIT.</a></font></LI>
  <LI> <P ALIGN="JUSTIFY"><FONT face="Times New Roman, sans-serif, Courier, mono" size="3">
  <a href="#s1313">Прогон программы с пользовательской обработкой сигнала SIGINT.</a></font></LI>
  <LI> <P ALIGN="JUSTIFY"><FONT face="Times New Roman, sans-serif, Courier, mono" size="3">
  <a href="#s1314">Модификация предыдущей программы для 
  пользовательской обработки сигналов SIGINT и SIGQUIT.</a></font></LI>
	<li><a href="#s1315"> 
    <P ALIGN="JUSTIFY"><font face="Times New Roman, Times, serif" size="3">
	Восстановление предыдущей реакции на сигнал. 
	</font> 
    </a></li>

  <LI><P ALIGN="JUSTIFY"><FONT face="Times New Roman, sans-serif, Courier, mono" size="3">
  <a href="#s1316">Сигналы 
    SIGUSR1 и SIGUSR2. Использование сигналов для синхронизации процессов.</a></font></LI>
 
  <LI><P ALIGN="JUSTIFY"><FONT face="Times New Roman, sans-serif, Courier, mono" size="3">
  <a href="#s1318">Прогон программы для иллюстрации обработки сигнала SIGCHLD.</a></FONT></LI>
  
  </OL>

  
  <P ALIGN="CENTER"><B><font face="Times New Roman, Times, serif" size="4">План
занятия</font></B></P>
<ol>
  <LI> 
    <p align="JUSTIFY"> <font  face="Times New Roman, Times, serif" size="3" color="#FF0000"><b> 
      <a name="s1301"></a>Понятие виртуальной файловой системы.</b></font> <br>
      <br>
    <p align="JUSTIFY"> <font face="Times New Roman, Times, serif" size="3"> На 
      <a href="../../11/prep/sem11-12.htm">предыдущих занятиях</a> мы с вами рассматривали 
      устройство файловой системы s5fs. Существуют и другие файловые системы, 
      имеющие архитектуру, существенно отличающуюся от архитектуры s5fs (иные 
      способы отображения файла на пространство физического носителя, иное построение 
      директорий и т.д.). Современные версии UNIX-подобных операционных систем 
      умеют работать с разнообразными файловыми системами, отличающимися своей 
      организацией. <a href="../../13/ch13.htm#l130201"><img border="0" src="../../images/bookopen.gif" 
    alt="Структура системы ввода-вывода в лекции" align="right" hspace="10" vspace="1" width="48" height="34"></a> 
      Такая возможность достигается с помощью разбиения каждой существующей файловой 
      системы на зависимую и независимую от конкретной реализации части, подобно 
      тому, как на лекции, посвященной вопросам ввода-вывода, мы отделяли аппаратно-зависимые 
      части для каждого устройства (драйвера) от общей базовой подсистемы ввода-вывода. 
      Независимые части всех файловых систем одинаковы и представляют для всех 
      остальных элементов ядра абстрактную файловую систему, которую принято называть 
      виртуальной файловой системой. Зависимые части для различных файловых систем 
      могут встраиваться в ядро на этапе компиляции, либо добавляться к нему динамически 
      по мере необходимости, без перекомпиляции системы (как в системах с микроядерной 
      архитектурой).<br>
      <br>
      Рассмотрим схематично устройство виртуальной файловой системы. В файловой 
      системе s5fs каждый открытый файл представлялся в операционной ситеме структурой 
      данных в <a href="../../11/prep/sem11-12.htm#s1108b">таблице индексных узлов 
      открытых файлов</a>, содержащей информацию из индексного узла файла во вторичной 
      памяти. В виртуальной файловой системе, в отличие от s5fs, каждый файл характеризуется 
      не индексным узлом inode, а некоторым виртуальным узлом vnode. При открытии 
      файла в операционной системе для него заполняется (если, конечно, не был 
      заполнен раньше) элемент <i>таблицы виртуальных узлов открытых файлов</i>, 
      в котором хранятся, как минимум, тип файла, счетчик числа открытий файла, 
      <u>указатель</u> на реальные физические данные файла и, <u>обязательно</u>, 
      <u>указатель</u> на таблицу системных вызовов, совершающих операции над 
      файлом, - <i>таблицу операций</i>. Реальные физические данные файла (равно 
      как и способ расположения файла на диске, и т.п.) и системные вызовы, реально 
      выполняющие операции над файлом, уже не являются элементами виртуальной 
      файловой системы. Они относятся к одной из зависимых частей файловой системы, 
      так как определяются ее конкретной реализацией. <br>
      <br>
      При выполнении операций над файлами по таблице операций, адрес которой содержится 
      в vnode, определяется системный вызов, который будет на самом деле выполнен 
      над реальными физическими данными файла, адрес которых также находится в 
      vnode. <a href="../../12/ch12.htm#l120301"><img border="0" src="../../images/bookopen.gif" 
    alt="Метод индексных узлов в лекции" align="right" hspace="10" vspace="1" width="48" height="34"></a> 
      В случае с s5fs, данные, на которые ссылается vnode, — это как раз данные 
      индексного узла, рассмотренные <a href="../../11/prep/sem11-12.htm#s1104a">на 
      предыдущих семинарах</a> и на соответствующей лекции. Заметим, что таблица 
      операций является общей для всех файлов, принадлежащих одной и той же файловой 
      системе.<br>
      &nbsp;<br>
      </font> 
  </li>
  <LI> 
    <p align="JUSTIFY"> <font  face="Times New Roman, Times, serif" size="3" color="#FF0000"><b> 
      <a name="s1302"></a>Операции над файловыми системами. Монтирование файловых 
      систем.</b></font> <br>
      <br>
    <p align="JUSTIFY"> <font face="Times New Roman, Times, serif" size="3"> На 
      <a href="../../11/prep/sem11-12.htm">предыдущих семинарах</a> мы рассматривали 
      только одну файловую систему, расположенную в одном разделе физического 
      носителя. Как только мы переходим к взаимному сосуществованию нескольких 
      файловых систем в рамках одной операционной системы, встает вопрос о логическом 
      объединении структур этих файловых систем. При начале работы операционной 
      системы нам изначально доступна лишь одна, так называемая корневая, файловая 
      система. <a href="../../12/ch12.htm#l1205"><img border="0" src="../../images/bookopen.gif" 
    alt="Операция монтирования в лекции" align="right" hspace="10" vspace="1" width="48" height="34"></a> 
      Прежде, чем приступить к работе с файлом, лежащим в некоторой другой файловой 
      системе, мы должны встроить ее в уже существующий ациклический граф файлов. 
      Эта операция - операция над файловой системой - называется монтированием 
      файловой системы (<b>mount</b>). <br>
      <br>
      Для монтирования файловой системы в существующем графе должна быть найдена 
      или создана некоторая пустая директория - точка монтирования, к которой 
      и присоединится корень монтируемой файловой системы. При операции монтировании 
      в ядре заводятся структуры данных, описывающие файловую систему, а в vnode 
      для точки монтирования файловой системы помещается специальная информация. 
      <br>
      <br>
      Монтирование файловых систем обычно является прерогативой системного администатора 
      и осуществляется командой операционной системы <a href="../../man/mount.htm">mount</a> 
      в ручном режиме, либо автоматически при старте операционной системы. Использование 
      этой команды без параметров не требует специальных полномочий и позволяет 
      пользователю получить информацию о всех подмонтированных файловых системах 
      и соответствующих им физических устройствах. Для пользователя также обычно 
      разрешается монтирование файловых систем, расположенных на гибких магнитных 
      дисках. Для первого накопителя на гибких магнитных дисках такая команда 
      в Linux будет выглядеть следующим образом: </font> 
    <p align="center"> <font face="Times New Roman, Times, serif" size="3"> <b><font color="#008000"><a href="../../man/mount.htm">mount</a> 
      /dev/fd0 &lt;имя пустой директории&gt;</font></b>, </font> 
    <p align="JUSTIFY"> <font face="Times New Roman, Times, serif" size="3"> где 
      <b> <font color="#008000">&lt;имя пустой директории&gt;</font></b> описывает 
      точку монтирования, а <b><font color="#008000">/dev/fd0</font></b> - специальный 
      файл устройства, соответствующего этому накопителю (о специальных файлах 
      устройств мы подробнее поговорим в <a href="#s1303">следующем разделе</a>). 
      <br>
      <br>
      Если мы не собираемся использовать подмонтированную файловую систему в дальнейшем 
      (например, хотим вынуть ранее подмонтированную дискету), нам необходимо 
      выполнить операцию логического разъединения смонтированных файловых систем 
      (umount). Для этой операции, которая тоже, как правило, является привилегией 
      системного администратора, используется команда <a href="../../man/umount.htm">umount</a> 
      (может выполняться в ручном режиме или автоматически при завершении работы 
      операционной системы). Для пользователя обычно доступна команда по отмонтированию 
      файловой системы на дискете в форме</font> 
    <p align="center"> <font face="Times New Roman, Times, serif" size="3"> <b><font color="#008000"><a href="../../man/umount.htm">umount</a> 
      &lt;имя точки монтирования&gt;</font></b>, </font> 
    <p align="JUSTIFY"> <font face="Times New Roman, Times, serif" size="3"> где 
      <font color="#008000"><b>&lt;имя точки монтирования&gt;</b></font> - это 
      <b> <font color="#008000">&lt;имя пустой директории&gt;</font></b>, использованное 
      ранее в команде <a href="../../man/mount.htm">mount</a>, или в форме </font> 
    <p align="center"> <font face="Times New Roman, Times, serif" size="3"> <b><font color="#008000"><a href="../../man/umount.htm">umount</a> 
      /dev/fd0</font></b>, </font> 
    <p align="JUSTIFY"> <font face="Times New Roman, Times, serif" size="3"> где 
      <b> <font color="#008000">/dev/fd0</font></b> - специальный файл устройства, 
      соответствующего первому накопителю на гибких магнитных дисках. <img border="0" src="../../images/znak.gif" align="left" vspace="8" alt="Nota bene" hspace="10"> 
      <u><b>Заметим, что для последующей корректной работы операционной системы 
      при удалении физического носителя информации, обязательно необходимо предварительное 
      логическое разъединение файловых систем, если они перед этим были объединены.</b></u><br>
      &nbsp;<br>
      </font> 
  </li>
  <LI> 
    <p align="JUSTIFY"> <font  face="Times New Roman, Times, serif" size="3" color="#FF0000"><b> 
      <a name="s1303"></a>Блочные, символьные устройства. Понятие драйвера. Блочные, 
      символьные драйверы, драйверы низкого уровня. Файловый интерфейс.</b></font> 
      <br>
      <br>
    <p align="JUSTIFY"> <font face="Times New Roman, Times, serif" size="3">Обремененные 
      знаниями об устройстве современных файловых систем в UNIX, мы можем, наконец, 
      заняться вопросами реализации подсистемы ввода-вывода.<br>
      <br>
      <a href="../../13/ch13.htm#l130201"><img border="0" src="../../images/bookopen.gif" 
    alt="Структура системы ввода-вывода в лекции" align="right" hspace="10" vspace="1" width="48" height="34"></a> 
      На лекции мы говорили о том, что все возможные устройства ввода-вывода можно 
      разделить на относительно небольшое число типов, отличающихся по набору 
      операций, которые могут быть ими выполнены, считая все остальные различия 
      несущественными. Такое деление позволяет организовать подсистему ввода-вывода 
      слоеным образом, вынеся все аппаратно-зависимые части в драйвера устройств, 
      с которыми взаимодействует базовая подсистема ввода-вывода, осуществляющая 
      стратегическое управление всеми устройствами. <br>
      <br>
      <a href="../../13/ch13.htm#l130202"><img border="0" src="../../images/bookopen.gif" 
    alt="Классификация устройств в лекции" align="right" hspace="10" vspace="1" width="48" height="34"></a> 
      В операционной системе UNIX принята упрощенная классификация устройств: 
      все устройства разделяются по способу передачи данных на символьные и блочные. 
      Символьные устройства осуществляют передачу данных байт за байтом, в то 
      время как блочные устройства передают блок байт как единое целое. Типичным 
      примером символьного устройства является клавиатура, типичным примером блочного 
      устройства является жесткий диск. Непосредственное взаимодействие операционной 
      системы с устройствами ввода-вывода обеспечивают их драйверы. Существует 
      пять основных случаев, когда ядро обращается к драйверам:</font><br>
      <br>
    <dir> 
      <OL >
        <LI> 
          <p align="JUSTIFY"><FONT face="Times New Roman, sans-serif, Courier, mono" size="3">Автоконфигурация. 
            Происходит в процессе инициализации операционной системы, когда ядро 
            определяет наличие доступных устройств.</FONT> 
        </LI>
        <LI> 
          <p align="JUSTIFY"><FONT face="Times New Roman, sans-serif, Courier, mono" size="3">Ввод-вывод. 
            Обработка запроса ввода-вывода.</FONT> 
        </LI>
        <LI> 
          <p align="JUSTIFY"><FONT face="Times New Roman, sans-serif, Courier, mono" size="3">Обработка 
            прерываний. Ядро вызывает специальные функции драйвера для обработки 
            прерывания, поступившего от устройства, в том числе, возможно, для 
            планирования очередности запросов к нему.</FONT> 
        </LI>
        <LI> 
          <p align="JUSTIFY"><FONT face="Times New Roman, sans-serif, Courier, mono" size="3">Специальные 
            запросы. Например, изменение параметров драйвера или устройства.</FONT> 
        </LI>
        <LI> 
          <p align="JUSTIFY"><FONT face="Times New Roman, sans-serif, Courier, mono" size="3">Повторная 
            инициализация устройства или останов операционной системы.</FONT> 
        </LI>
        <br>
      </OL>
    </dir>
    <p align="JUSTIFY"><FONT face="Times New Roman, sans-serif, Courier, mono" size="3">Так 
      же как устройства подразделяются на символьные и блочные, так и драйверы 
      существуют символьные и блочные. Особенностью блочных устройств является 
      возможность организации на них файловой системы, поэтому блочные драйверы 
      обычно используются файловой системой UNIX. При обращении к блочному устройству, 
      не содержащему файловой системы, применяются специальные драйверы низкого 
      уровня, как правило, представляющие собой интерфейс между ядром операционной 
      системы и блочным драйвером устройства. <br>
      <br>
      <a href="../../13/ch13.htm#l130202a"><img border="0" src="../../images/bookopen.gif" 
    alt="Интерфейс к драйверам в лекции" align="right" hspace="10" vspace="1" width="48" height="34"></a> 
      Для каждого из этих трех типов драйверов были выделены основные функции, 
      которые базовая подсистема ввода-вывода может совершать над устройствами 
      и драйверами: инициализация устройства или драйвера, временное завершение 
      работы устройства, чтение, запись, обработка прерывания, опрос устройства 
      и т.д. (об этих операциях мы уже говорили на лекции). Эти функции были систематизированы 
      и представляют собой интерфейс между драйверами и базовой подсистемой ввода-вывода.<br>
      <br>
      Каждый драйвер определенного типа в операционной системе UNIX получает свой 
      собственный номер, который по сути дела является индексом в массиве специальных 
      структур данных операционной системы — <i>коммутаторе устройств</i> соответствующего 
      типа. Этот индекс принято также называть <i>старшим номером устройства</i>, 
      хотя на самом деле он относится не к устройству, а к драйверу. Несмотря 
      на наличие трех типов драйверов, в операционной системе используется всего 
      два коммутатора: для блочных и символьных драйверов. Драйвера низкого уровня 
      распределяются между ними по преобладающему типу интерфейса (к какому типу 
      ближе - в такой массив и заносятся). Каждый элемент коммутатора устройств 
      обязательно содержит адреса (точки входа в драйвер), соответствующие стандартному 
      набору функций интерфейса, которые и вызываются операционной системой для 
      выполнения тех или иных действий над устройством и/или драйвером.<br>
      <br>
      Помимо старшего номера устройства существует еще и <i>младший номер устройства</i>, 
      который передается драйверу в качестве параметра и смысл которого определяется 
      самим драйвером. Например, это может быть номер раздела на жестком диске 
      (partition), доступ к которому должен обеспечить драйвер (надо отметить, 
      что в операционной системе UNIX различные разделы физического носителя информации 
      рассматриваются как различные устройства). В некоторых случаях младший номер 
      устройства может не использоваться, но для единообразия он обязан присутствовать. 
      Таким образом, пара драйвер-устройство всегда однозначно определяется в 
      операционной системе заданием пары номеров (старшего и младшего номеров 
      устройства) и типа драйвера (символьный или блочный). <br>
      <br>
      Для связи приложений с драйверами устройств операционная система UNIX использует 
      <i>файловый интерфейс</i>. В числе типов файлов <a href="../../11/prep/sem11-12.htm#s1103">на 
      предыдущем семинаре</a> мы упоминали специальные файлы устройств. Так вот, 
      каждой тройке тип-драйвер-устройство в файловой системе соответствует специальный 
      файл устройства, который не занимает на диске никаких логических блоков, 
      кроме индексного узла. В качестве атрибутов этого файла помимо обычных атрибутов 
      используются соответствующие старший и младший номера устройства и тип драйвера 
      (тип драйвера определяется по типу файла - ибо есть специальные файлы символьных 
      устройств и специальные файлы блочных устройств, а номера устройств занимают 
      место длины файла для, скажем, регулярных файлов). Когда открывается специальный 
      файл устройства, операционная система, в числе прочих действий, заносит 
      в соотвествующий элемент таблицы открытых виртуальных узлов указатель на 
      набор функций интерфейса из соответствующего элемента коммутатора устройств. 
      Теперь при попытке чтения из файла устройства или записи в файл устройства 
      виртуальная файловая система будет транслировать запросы на выполнение этих 
      операций в необходимые вызовы нужного драйвера. <br>
      <br>
      Мы не будем останавливаться на практическом применении файлового интерфейса 
      для работы с устройствами ввода-вывода, поскольку это выходит за пределы 
      нашего курса, а вместо этого приступим к изложению концепции сигналов в 
      UNIX, тесно связанных с понятиями аппаратного прерывания, исключения и программного 
      прерывания. <br>
      &nbsp;<br>
      </font> 
  </li>
  <LI> 
    <p align="JUSTIFY"> <font  face="Times New Roman, Times, serif" size="3" color="#FF0000"><b> 
      <a name="s1304"></a>Аппаратные прерывания (interrupt), исключения (exception), 
      программные прерывания (trap, software interrupt). Их обработка.</b></font> 
      <br>
      <br>
    <p align="JUSTIFY"> <font face="Times New Roman, Times, serif" size="3"> <a href="../../13/ch13.htm#l130103"><img border="0" src="../../images/bookopen.gif" 
    alt="Прерывания и polling в лекции" align="right" hspace="10" vspace="1" width="48" height="34"></a> 
      На лекциях уже вводились понятия аппаратного прерывания, исключения и программного 
      прерывания. Кратко напомним сказанное.<br>
      <br>
      После выдачи запроса ввода-вывода у процессора существует два способа узнать 
      о том, что обработка запроса устройством завершена. Первый способ заключается 
      в регулярной проверке процессором <i><b>бита занятости</b></i> в <i><b>регистре 
      состояния</b></i> контроллера соответствующего устройства (polling). Второй 
      способ заключается в использовании прерываний. При втором способе процессор 
      имеет специальный вход, на который устройства ввода-вывода непосредственно, 
      или используя контроллер прерываний, выставляют сигнал запроса прерывания 
      (interrupt request) при завершении операции ввода-вывода. При наличии такого 
      сигнала, процессор, после выполнения текущей команды, не выполняет следующую, 
      а, сохранив состояние ряда регистров и, возможно, загрузив в часть регистров 
      новые значения, переходит на выполнение команд, расположенных по некотором 
      фиксированным адресам. После окончания обработки прерывания можно восстановить 
      состояние процессора и продолжить его работу с команды, выполнение которой 
      было отложено. <br>
      <br>
      Аналогичный механизм часто используется при обработке исключительных ситуаций 
      (exception), возникающих при выполнении команды процессором (неправильный 
      адрес в команде, защита памяти, возникло деление на ноль и т.д.). В этом 
      случае процессор не заканчивает выполнение команды, а поступает, как и при 
      прерывании, сохраняя свое состояние до момента начала ее выполнения. <br>
      <br>
      Этим же механизмом часто пользуются и для реализации так называемых программных 
      прерываний (software interrupt, trap), используемых, например, для переключения 
      процессора из режима пользователя в режим ядра внутри системных вызовов. 
      Для выполнения действий аналогичных действиям по обработке прерывания процессор, 
      в этом случае, должен выполнить специальную команду.<br>
      <br>
      <u><b><img border="0" src="../../images/znak.gif" align="left" vspace="8" alt="Nota bene" hspace="10"> 
      <a href="../../13/ch13.htm#l130103a1"><img border="0" src="../../images/bookopen.gif" 
    alt="Interrupt,exception и trap в лекции" align="right" hspace="10" vspace="1" width="48" height="34"></a> 
      Необходимо четко представлять себе разницу между этими тремя понятиями, 
      для чего не лишним будет в очередной раз обратиться к лекциям.</b></u><br>
      <br>
      Как правило, обработку аппаратных прерываний от устройств ввода-вывода производит 
      сама операционная система, не доверяя работу с системными ресурсами процессам 
      пользователя. Обработка же исключительных ситуаций и некоторых программных 
      прерываний вполне может быть возложена на пользовательский процесс через 
      механизм сигналов. <br>
      &nbsp;<br>
      </font> 
  </li>
  <LI> 
    <p align="JUSTIFY"> <font  face="Times New Roman, Times, serif" size="3" color="#FF0000"><b> 
      <a name="s1305"></a>Понятие сигнала. Способы возникновения сигналов и виды 
      их обработки. </b></font> <br>
      <br>
    <p align="JUSTIFY"><FONT face="Times New Roman, sans-serif, Courier, mono" size="3">С 
      точки зрения пользователя получение процессом сигнала выглядит как возникновение 
      прерывания. Процесс прекращает свое регулярное исполнение, и управление 
      передается механизму обработки сигнала. По окончании обработки сигнала процесс 
      может возобновить регулярное исполнение. Типы сигналов (их принято задавать 
      номерами, как правило, в диапазоне от 1 до 31 включительно или специальными 
      символьными обозначениями) и способы их возникновения в системе жестко регламентированы.<br>
      <br>
      <a name="s1305a"></a>Процесс может получить сигнал от:</FONT><br>
      <br>
    <dir> 
      <OL>
        <LI> 
          <p align="JUSTIFY"><FONT face="Times New Roman, sans-serif, Courier, mono" size="3">Hardware 
            (при возникновении исключительной ситуации).</font> 
        </LI>
        <LI> 
          <p align="JUSTIFY"><FONT face="Times New Roman, sans-serif, Courier, mono" size="3">Другого 
            процесса, выполнившего системный вызов передачи сигнала.</FONT> 
        </LI>
        <LI> 
          <p align="JUSTIFY"><FONT face="Times New Roman, sans-serif, Courier, mono" size="3">Операционной 
            системы (при наступлении некоторых событий).</FONT> 
        </LI>
        <LI> 
          <p align="JUSTIFY"><FONT face="Times New Roman, sans-serif, Courier, mono" size="3">Терминала 
            (при нажатии определенной комбинации клавиш).</FONT> 
        </LI>
        <LI> 
          <p align="JUSTIFY"><FONT face="Times New Roman, sans-serif, Courier, mono" size="3">Системы 
            управления заданиями (при выполнении команды<b><font color="#008000"> 
            kill</font></b> - мы рассмотрим ее позже).</font> 
        </LI>
        <br>
      </OL>
    </dir>
    <p align="JUSTIFY"><FONT face="Times New Roman, sans-serif, Courier, mono" size="3"> 
      <a href="../../04/ch4.htm#l0402"><img border="0" src="../../images/bookopen.gif" 
    alt="Сигналы в лекции" align="right" hspace="10" vspace="1" width="48" height="34"></a> 
      Передачу сигналов процессу в случаях его генерации источниками 2, 3 и 5, 
      т.е. в конечном счете каким-либо другим процессом, можно рассматривать как 
      реализацию в UNIX сигнальных средств связи, о которых мы говорили на <a href="../../04/l4.htm">лекции 
      4</a>.</font></p>
    <p align="JUSTIFY"><FONT face="Times New Roman, sans-serif, Courier, mono" size="3"><a name="s1305b"></a>Существует 
      три варианта реакции процесса на сигнал:</FONT><br>
      <br>
    <dir> 
      <OL>
        <LI> 
          <p align="JUSTIFY"><FONT face="Times New Roman, sans-serif, Courier, mono" size="3">Принудительно 
            проигнорировать сигнал.</FONT> 
        </LI>
        <LI> 
          <p align="JUSTIFY"><FONT face="Times New Roman, sans-serif, Courier, mono" size="3">Произвести 
            обработку по умолчанию (проигнорировать, остановить процесс (перевести 
            в состояние ожидания до получения другого специального сигнала), либо 
            завершить работу с образование core файла или без оного).</font> 
        </LI>
        <LI> 
          <p align="JUSTIFY"><FONT face="Times New Roman, sans-serif, Courier, mono" size="3">Выполнить 
            обработку сигнала, специфицированную пользователем.</FONT> 
        </LI>
        <br>
      </OL>
    </dir>
    <p align="JUSTIFY"><FONT face="Times New Roman, sans-serif, Courier, mono" size="3">Изменить 
      реакцию процесса на сигнал можно с помощью специальных системных вызовов, 
      которые мы рассмотрим позже. Реакция на некоторы сигналы не допускает изменения 
      и они могут быть обработаны только по умолчанию. Так, например, сигнал с 
      номером 9 — <b><font color="#008000">SIGKILL</font></b> обрабатывается только 
      по умолчанию и всегда приводит к завершению процесса. <br>
      <br>
      <img border="0" src="../../images/znak.gif" align="left" vspace="8" alt="Nota bene" hspace="10"> 
      <b><u> Важным вопросом при программировании с использованием сигналов является 
      вопрос о сохранении реакции на них при рождении нового процесса или замене 
      его пользовательского контекста. При системном вызове</u> <a href="../../man/fork.htm">fork()</a> 
      <u>все установленные реакции на сигналы наследуется порожденным процессом. 
      При системном вызове</u> <a href="../../man/exec.htm">exec()</a> <u>сохраняются 
      реакции только для тех сигналов, которые игнорировались или обрабатывались 
      по умолчанию. Получение любого сигнала, который до вызова</u> <a href="../../man/exec.htm">exec()</a> 
      <u>обрабатывался пользователем, приведет к завершению процесса.</u></b><br>
      <br>
      Прежде, чем продолжить дальнейший разговор о сигналах, нам придется подробнее 
      остановиться на иерархии процессов в операционной системе.<br>
      &nbsp;<br>
      </font> 
  </li>
  <LI> 
    <p align="JUSTIFY"> <font  face="Times New Roman, Times, serif" size="3" color="#FF0000"><b> 
      <a name="s1306"></a>Понятия группы процессов, сеанса, лидера группы, лидера 
      сеанса, управляющего терминала сеанса. Системные вызовы getpgrp(), setpgrp(), 
      getpgid(), setpgid(), getsid(), setsid()</b></font> <br>
      <br>
    <p align="JUSTIFY"> 
    <font face="Times New Roman, Times, serif" size="3"> 
    <p align="JUSTIFY"><FONT face="Times New Roman, sans-serif, Courier, mono" size="3"><a href="../../02/ch2.htm#l020303">Мы 
      уже говорили</a>, что все процессы в системе связаны родственными отношениями, 
      образуя генеалогическое дерево или лес из таких деревьев, где в качестве 
      узлов деревьев выступают сами процессы, а связями служат отношения родитель-ребенок. 
      Все эти деревья принято разделять на <i>группы процессов</i>, так сказать, 
      семьи (см. рисунок). <br>
      <br>
      Группа процессов включает в себя один или более процессов и существует, 
      пока в группе присутствует хотя бы один процесс. Каждый процесс обязательно 
      включен в какую-нибудь группу. При рождении нового процесса он попадает 
      в ту же группу процессов, в которой находится его родитель. Процессы могут 
      мигрировать из группы в группу по своему собственному желанию или по желанию 
      другого процесса (в зависимости от версии UNIX). Многие системные вызовы 
      могут быть применены не к одному конкретному процессу, а ко всем процессам 
      в некоторой группе. Поэтому то, как именно вы будете объединять процессы 
      в группы, зависит от того, как вы собираетесь их использовать. Чуть позже 
      мы поговорим об использовании групп процессов для передачи сигналов. </font></P>
    <p align="center"><img src="../images/s8-9-1s.gif" width="400" height="268"></P>
    <p align="JUSTIFY"><font face="Times New Roman, sans-serif, Courier, mono">В 
      свою очередь,</font><font face="Times New Roman, sans-serif, Courier, mono" size="3"> 
      группы процессов объединяются в <i>сеансы</i>, образуя с родственной точки 
      зрения некие кланы семей. Понятие сеанса изначально было введено в UNIX 
      для логического объединения групп процессов, созданных в результате каждого 
      входа и последующей работы пользователя в системе. С каждым сеансом, поэтому, 
      может быть связан в системе терминал, называемый <i>управляющим терминалом</i> 
      сеанса, через который обычно и общаются процессы сеанса с пользователем. 
      Сеанс не может иметь более одного управляющего терминала, и один терминал 
      не может быть управляющим для нескольких сеансов. В то же время могут существовать 
      сеансы, вообще не имеющие управляющего терминала.</font></P>
    <p align="JUSTIFY"><FONT face="Times New Roman, sans-serif, Courier, mono" size="3">Каждая 
      группа процессов в системе получает свой собственный уникальный номер. Узнать 
      этот номер можно с помощью системного вызова <a href="../../man/getpgid.htm">getpgid()</a>. 
      Используя его, процесс может узнать номер группы для себя самого или для 
      процесса из своего сеанса. К сожалению, не во всех версиях UNIX присутствует 
      данный системный вызов. Здесь мы сталкиваемся с тяжелым наследием разделения 
      линий UNIX'ов на линию BSD и линию System V, которое будет нас преследовать 
      почти на всем протяжении данной темы. Вместо вызова <a href="../../man/getpgid.htm">getpgid()</a> 
      в таких системах существует системный вызов <a href="../../man/getpgrp.htm">getpgrp()</a>, 
      который возвращает вам номер группы только для текущего процесса.</font></P>
    <p align="JUSTIFY"><font face="Times New Roman, sans-serif, Courier, mono">Для 
      перевода процесса в другую группу процессов, возможно с одновременным ее 
      созданием, применяется системный вызов <a href="../../man/setpgid.htm">setpgid()</a>. 
      Перевести в другую группу процесс может либо самого себя (и то не во всякую 
      и не всегда), либо свой процесс-ребенок, который не выполнял системный вызов 
      <a href="../../man/exec.htm">exec()</a>, т.е. не запускал на выполнение 
      другую программу. При определенных значениях параметров системного вызова 
      создается новая группа процессов с идентификатором, совпадающим с идентификатором 
      переводимого процесса, состоящая первоначально только из одного этого процесса. 
      Новая группа может быть создана только таким способом, поэтому идентификаторы 
      групп в системе уникальны. Переход в другую группу без создания новой группы 
      возможен только в пределах одного сеанса.<br>
      <br>
      В некоторых разновидностях UNIX системный вызов <a href="../../man/setpgid.htm">setpgid()</a> 
      отсутствует, а вместо него существует системный вызов <a href="../../man/setpgrp.htm">setpgrp()</a>, 
      который умеет только создавать новую группу процессов с идентификатором, 
      совпадаюшим с идентификатором текущего процесса, и переводить текущий процесс 
      в нее.</font> (В некоторых разновидностях UNIX, где совместно сосуществуют 
      вызовы <a href="../../man/setpgrp.htm">setpgrp()</a> и <a href="../../man/setpgid.htm">setpgid()</a>, 
      например в Solaris, вызов <a href="../../man/setpgrp.htm">setpgrp()</a> 
      ведет себя иначе - он аналогичен рассматриваемому ниже вызову <a href="../../man/setsid.htm">setsid()</a>.) 
    <p align="JUSTIFY"><FONT face="Times New Roman, sans-serif, Courier, mono" size="3">Процесс, 
      идентификатор которого совпадает с идентификатором его группы, называется 
      <i>лидером группы</i>. Одно из ограничений на применение вызовов <a href="../../man/setpgid.htm">setpgid()</a> 
      и <a href="../../man/setpgrp.htm">setpgrp()</a> состоит в том, что лидер 
      группы не может перебраться в другую группу. </font></P>
    <p align="JUSTIFY"> <FONT face="Times New Roman, sans-serif, Courier, mono" size="3">Каждый 
      сеанс в системе также имеет свой собственный номер. Для того, чтобы узнать 
      его можно воспользоваться системным вызовом <a href="../../man/getsid.htm">getsid()</a>. 
      В разных версиях UNIX на него накладываются различные ограничения. В Linux 
      такие ограничения отсутствуют. </font></P>
    <p align="JUSTIFY"><FONT face="Times New Roman, sans-serif, Courier, mono" size="3">Использование 
      системного вызова <a href="../../man/setsid.htm">setsid()</a> приводит к 
      созданию новой группы, состоящий только из процесса, который его выполнил 
      (он становится лидером новой группы), и нового сеанса, идентификатор которого 
      совпадает с идентификатором процесса, сделавшего вызов. Такой процесс называется 
      <i>лидером сеанса</i>. Этот системный вызов может применять только процесс, 
      не являющийся лидером группы.</font></P>
    <p align="JUSTIFY"><FONT face="Times New Roman, sans-serif, Courier, mono" size="3">Если 
      сеанс имеет управляющий терминал, то он обязательно приписывается к некоторой 
      группе процессов, входящей в сеанс. Такая группа процессов называется <i>текущей 
      группой процессов</i> для данного сеанса. Все процессы, входящие в текущую 
      группу процессов могут совершать операции ввода-вывода, используя управляющий 
      терминал. Все остальные группы процессов сеанса называются <i>фоновыми группами</i>, 
      а процессы, входящие в них — <i>фоновыми процессами</i>. При попытке ввода-вывода 
      фонового процесса через управляющий терминал, этот процесс получит сигналы, 
      которые стандартно приводят к прекращению работы процесса. Передавать управляющий 
      терминал от одной группы процессов к другой может только лидер сеанса. Заметим, 
      что для сеансов, не имеющих управляющего терминала, все процессы являются 
      фоновыми.</font></P>
    <p align="JUSTIFY"><FONT face="Times New Roman, sans-serif, Courier, mono" size="3">При 
      завершении работы процесса — лидера сеанса все процессы из текущей группы 
      сеанса получают сигнал <b><font color="#008000">SIGHUP</font></b>, который 
      при стандартной обработке приведет к их завершению. Таким образом, после 
      завершения лидера сеанса в нормальной ситуации работать продолжат только 
      фоновые процессы.</font></P>
    <p align="JUSTIFY"><FONT face="Times New Roman, sans-serif, Courier, mono" size="3">Процессы, 
      входящие в текущую группу сеанса, могут получать сигналы, инициируемые нажатием 
      определенных клавиш на терминале — <b><font color="#008000">SIGINT </font></b>при 
      нажатии клавиш &lt;ctrl&gt; и &lt;c&gt;, и <b><font color="#008000">SIGQUIT</font></b> 
      при нажатии клавиш &lt;ctrl&gt; и &lt;4&gt;. Стандартная реакция процесса 
      на эти сигналы — завершение процесса.</font></P>
    <p align="JUSTIFY"><FONT face="Times New Roman, sans-serif, Courier, mono" size="3">Нам 
      понадобится еще одно понятие, связанное с процессом, — эффективный идентификатор 
      пользователя. В начале семестра мы говорили, что каждый пользователь в системе 
      имеет свой собственный идентификатор — <b><font color="#008000">UID</font></b>. 
      Каждый процесс, запущенный пользователем, использует этот <b><font color="#008000">UID</font></b> 
      для определения своих полномочий. Однако иногда, если у исполняемого файла 
      были выставлены соответствующие атрибуты, процесс может прикинуться процессом, 
      запущенным другим пользователем. Идентификатор пользователя, от имени которого 
      процесс пользуется полномочиями, и является эффективным идентификатором 
      пользователя для процесса — <b><font color="#008000">EUID</font></b>. За 
      исключением выше оговоренного случая, эффективный идентификатор пользователя 
      совпадает с идентификатором пользователя, создавшего процесс.</font></P>
    </font> </li>
  <LI> 
    <p align="JUSTIFY"> <font  face="Times New Roman, Times, serif" size="3" color="#FF0000"><b> 
      <a name="s1307"></a>Системный вызов kill() и команда kill().</b></font> 
      <br>
      <br>
    <p align="JUSTIFY"> 
    <font face="Times New Roman, Times, serif" size="3"> 
    <p align="JUSTIFY"><FONT face="Times New Roman, sans-serif, Courier, mono" size="3">Из 
      всех <a href="#s1305a">перечисленных ранее</a> источников сигнала пользователю 
      доступны только два — команда <a href="../../man/kill1.htm">kill</a> и посылка 
      сигнала процессу с помощью системного вызова <a href="../../man/kill2.htm">kill()</a><i>. 
      </i>Команда <a href="../../man/kill1.htm">kill</a><i> </i>обычно используется 
      в следующей форме:</font></P>
    <DIR> 
      <p align="JUSTIFY"><a href="../../man/kill1.htm"><FONT size="3">kill</font></a><FONT size="3"> 
        <b><font color="#008000">[-номер] pid</font></b></font></P>
    </DIR>
    <p align="JUSTIFY"><FONT face="Times New Roman, sans-serif, Courier, mono" size="3">Здесь 
      <b> <font color="#008000">pid</font></b> — это идентификатор процесса, которому 
      посылается сигнал, а “<b><font color="#008000">номер</font></b>” — номер 
      сигнала, который посылается процессу. Послать сигнал (если у вас нет полномочий 
      суперпользователя) можно только процессу, у которого эффективный идентификатор 
      пользователя совпадает с идентификатором пользователя, посылающего сигнал. 
      Если параметр <b><font color="#008000">–номер</font></b> отсутствует, то 
      посылается сигнал <font color="#008000"><b>SIGTERM</b></font>, обычно имеющий 
      номер <b><font color="#008000">15</font></b> и реакция на него по умолчанию 
      — завершить работу процесса, который получил сигнал.<br>
      <br>
      При использовании системного вызова <a href="../../man/kill2.htm">kill()</a> 
      послать сигнал (если у вас нет полномочий суперпользователя) можно только 
      процессу или процессам, у которых эффективный идентификатор пользователя 
      совпадает с эффективным идентификатором пользователя процесса, посылающего 
      сигнал. </font></P>
    </font></li>
  <LI> 
    <p align="JUSTIFY"> <font  face="Times New Roman, Times, serif" size="3" color="#FF0000"><b> 
      <a name="s1308"></a>Изучение особенностей получения терминальных сигналов 
      текущей и фоновой группой процессов.</b></font> <br>
      <br>
    <p align="JUSTIFY"> <font face="Times New Roman, Times, serif" size="3"> Давайте 
      возьмем <a href="../stud/13-1c.htm">тривиальную программу</a> /ftp/pub/sem/sem13-14/stud/13-1.c, 
      в которой процесс порождает ребенка и они оба зацикливаются, и на ее основе 
      проиллюстрируем сказанное выше.<br>
      <br>
      Для этого </font><font face="Times New Roman, sans-serif, Courier, mono" size="3">мы 
      будем использовать команду <b><font color="#008000">ps</font></b><i> </i>с 
      опцией <b><font color="#008000">-ej</font></b>, которая позволяет получить 
      информацию о всех процессах в системе и узнать их идентификаторы, идентификаторы 
      групп процессов и сеансов, управляющий терминал сеанса и к какой группе 
      процессов он приписан. Набрав команду “<b><font color="#008000">ps -ej</font></b>” 
      мы получим список всех процессов в системе. Колонка PID содержит идентификаторы 
      процессов, колонка PGID — идентификаторы групп, к которым они принадлежат, 
      колонка SID — идентификаторы сеансов, колонка TTY — номер соответствующего 
      управляющего терминала, колонка TPGID (может присутствовать не для всех 
      версий UNIX, но в Linux есть) — к какой группе процессов приписан управляющий 
      терминал.</font> <font face="Times New Roman, Times, serif" size="3"> <br>
      <br>
      Откомпилируйте тривиальную программу и запустите ее на исполнение (лучше 
      всего из под оболочки Midnight Commander - mc). Запустив команду </font><font face="Times New Roman, sans-serif, Courier, mono" size="3">“<b><font color="#008000">ps 
      -ej</font></b>”</font> <font face="Times New Roman, Times, serif" size="3">с 
      другого экрана, проанализируйте значения идентификаторов группы процессов, 
      сеансов, прикрепления управляющего терминала, текущей и фоновой групп. Убедитесь, 
      что тривиальные процессы относятся к текущей группе сеанса. Проверьте реакцию 
      текущей группы на сигналы <b><font color="#008000">SIGINT</font></b> - клавиши 
      &lt;CTRL&gt; и &lt;C&gt; - и сигнал <b><font color="#008000">SIGQUIT</font></b> 
      - клавиши &lt;CTRL&gt; и &lt;4&gt;. <br>
      <br>
      Запустите теперь тривиальную программу в фоновом режиме, например командой 
      </font><font face="Times New Roman, sans-serif, Courier, mono" size="3">“<b><font color="#008000">a.out 
      &amp;</font></b>”.</font><font face="Times New Roman, Times, serif" size="3"> 
      Проанализируйте значения идентификаторов группы процессов, сеансов, прикрепления 
      управляющего терминала, текущей и фоновой групп. Убедитесь, что тривиальные 
      процессы относятся к фоновой группе сеанса. Проверьте реакцию фоновой группы 
      на сигналы <b><font color="#008000">SIGINT</font></b> - клавиши &lt;CTRL&gt; 
      и &lt;C&gt; - и сигнал <b><font color="#008000">SIGQUIT</font></b> - клавиши 
      &lt;CTRL&gt; и &lt;4&gt;. Ликвидируйте тривиальные процессы с помощью команды 
      <a href="../../man/kill1.htm">kill</a>.<br>
      &nbsp;<br>
      </font> 
  </li>
  <LI> 
    <p align="JUSTIFY"> <font  face="Times New Roman, Times, serif" size="3" color="#FF0000"><b> 
      <a name="s1309"></a>Изучение получения сигнала SIGHUP процессами при завершении 
      лидера сеанса.</b></font> <br>
      <br>
    <p align="JUSTIFY"> <font face="Times New Roman, Times, serif" size="3"> Возьмите 
      снова <a href="../stud/13-1c.htm">тривиальную программу</a> и запустите 
      ее на исполнение из под Midnight Commander в текущей группе. Проанализировав 
      значения идентификаторов группы процессов, сеансов, прикрепления управляющего 
      терминала, текущей и фоновой групп, убейте лидера сеанса для тривиальных 
      процессов. Убедитесь, что все процессы в текущей группе этого сеанса прекратили 
      свою работу.<br><br>
      Запустите тирвиальную программу в фоновом режиме. Снова убейте лидера сеанса 
      для тривиальных процессов. Убедитесь, что фоновая группа продолжает работать. 
      Ликвидируйте тривиальные процессы.<br>
      &nbsp;<br>
      </font> 
  </li>
  <LI> 
    <p align="JUSTIFY"> <font  face="Times New Roman, Times, serif" size="3" color="#FF0000"><b> 
      <a name="s1310"></a>Системный вызов signal(). Установка собственного обработчика 
      сигнала.</b></font> <br>
      <br>
    <p align="JUSTIFY"> <font face="Times New Roman, Times, serif" size="3"> Одним 
      из способов изменения поведения процесса при получении сигнала в операционной 
      системе UNIX является использование системного вызова <a href="../../man/signal.htm">signal()</a>. 
      </font></P>
    <p align="JUSTIFY"><FONT face="Times New Roman, sans-serif, Courier, mono" size="3">Этот 
      системный вызов имеет два параметра: один из них задает номер сигнала, реакцию 
      процесса на который мы хотим изменить, а второй определяет, как именно мы 
      собираемся ее менять. Для первого <a href="#s1305b">варианта реакции процесса 
      на сигнал</a> - его игнорирования - применется специальное значение этого 
      параметра <b><font color="#008000">SIG_IGN</font></b>. Например, если требуется 
      игнорировать сигнал <b><font color="#008000">SIGINT</font></b>, начиная 
      с некоторого места работы программы, в этом месте программы мы должны употребить 
      конструкцию</font><br>
      <br>
    <p align="JUSTIFY"><i><b><font face="Times New Roman, sans-serif, Courier, mono" size="3" color="#008000"> 
      (void) <a href="../../man/signal.htm">signal</a>(SIGINT, SIG_IGN);</font></b></i><FONT face="Times New Roman, sans-serif, Courier, mono" size="3"> 
      <br>
      <br>
      </font> 
    <p align="JUSTIFY"><FONT face="Times New Roman, sans-serif, Courier, mono" size="3"> 
      Для второго <a href="#s1305b">варианта реакции процесса на сигнал</a> - 
      восстановления его обработки по умолчанию - применется специальное значение 
      этого параметра <b><font color="#008000">SIG_DFL</font></b>. Для третьего 
      <a href="#s1305b">варианта реакции процесса на сигнал</a> в качестве значения 
      параметра подставляется указатель на пользовательскую функцию обработки 
      сигнала, которая должна иметь прототип вида </font><br>
      <br>
    <p align="JUSTIFY"><FONT face="Times New Roman, sans-serif, Courier, mono" size="3"> 
      <i><b><font color="#008000">void *handler(int); </font></b></i><br>
      <br>
      </font> 
    <p align="JUSTIFY"><FONT face="Times New Roman, sans-serif, Courier, mono" size="3"> 
      Ниже приведен пример скелета конструкции для пользовательской обработки 
      сигнала <b><font color="#008000">SIGHUP</font></b>. </font><br>
      <br>
    <p align="JUSTIFY"><FONT face="Times New Roman, sans-serif, Courier, mono" size="3"  color="#008000"> 
      <i><b>void *my_handler(int nsig) {</b></i></font> 
    <dir> 
      <p align="JUSTIFY"><FONT face="Times New Roman, sans-serif, Courier, mono" size="3"  color="#008000"> 
        <i><b> &lt;обработка сигнала&gt; </b></i></font> 
    </dir>
    <p align="JUSTIFY"><FONT face="Times New Roman, sans-serif, Courier, mono" size="3"  color="#008000"> 
      <i><b> }<br>
      <br>
      int main() { </b></i></font> 
    <dir> 
      <p align="JUSTIFY"><FONT face="Times New Roman, sans-serif, Courier, mono" size="3"  color="#008000"> 
        <i><b> ...<br>
        (void)<a href="../../man/signal.htm">signal</a>(SIGHUP, my_handler);<br>
        ... </b></i></font> 
    </dir>
    <p align="JUSTIFY"><FONT face="Times New Roman, sans-serif, Courier, mono" size="3" color="#008000"> 
      <i><b> } </b></i> </FONT><br>
      <br>
    <p align="JUSTIFY"><font face="Times New Roman, sans-serif, Courier, mono" size="3">В 
      качестве значения параметра в пользовательскую функцию обработки сигнала 
      (в нашем склете - параметр <i><b><font color="#008000">nsig</font></b></i>) 
      передается номер возникшего сигнала, так что одна и та же функция может 
      быть использована для различной обработки нескольких сигналов.</font><br>
      &nbsp;<br>
  </li>
  <LI> 
    <p align="JUSTIFY"> <font  face="Times New Roman, Times, serif" size="3" color="#FF0000"><b> 
      <a name="s1311"></a>Прогон программы, игнорирующей сигнал SIGINT.</b></font> 
      <br>
      <br>
    <p align="JUSTIFY"><font face="Times New Roman, Times, serif" size="3"> Давайте 
      рассмотрим <a href="../stud/13-3c.htm">программу</a>, расположенную в файле 
      /ftp/pub/sem/sem13-14/13-3.c. Эта программа не делает ничего полезного, 
      кроме переустановки реакции на нажатие клавиш &lt;ctrl&gt; и &lt;c&gt; на 
      игнорирование возникающего сигнала и своего бесконечного зацикливания. Откомпилируйте 
      и запустите эту <a href="../stud/13-3c.htm">программу</a>, убедитесь, что 
      на нажатие клавиш &lt;ctrl&gt; и &lt;c&gt; она не реагирует, а реакция на 
      нажатие клавиш &lt;ctrl&gt; и &lt;4&gt; осталась прежней.</font><br>
      &nbsp;<br>
  </li>
  <LI> 
    <p align="JUSTIFY"> <font  face="Times New Roman, Times, serif" size="3" color="#FF0000"><b> 
      <a name="s1312"></a>Модификация предыдущей программы для игнорирования сигналов 
      SIGINT и SIGQUIT.</b></font> <br>
      <br>
    <p align="JUSTIFY"> <font face="Times New Roman, Times, serif" size="3"> 
      Модифицируйте <a href="../stud/13-3c.htm">программу</a> из предыдущего примера 
      так, чтобы она перестала реагировать и на нажатие клавиш &lt;ctrl&gt; и 
      &lt;4&gt;. Откомпилируйте и запустите ее, убедитесь в отсутствии ее реакций 
      на внешние раздражители. Снимать программу придется теперь с другого терминала 
      командой <a href="../../man/kill1.htm">kill</a>.<br>
      &nbsp;<br>
      </font> 
  </li>
  <LI> 
    <p align="JUSTIFY"> <font  face="Times New Roman, Times, serif" size="3" color="#FF0000"><b> 
      <a name="s1313"></a>Прогон программы с пользовательской обработкой сигнала 
      SIGINT.</b></font> <br>
      <br>
    <p align="JUSTIFY"><font face="Times New Roman, Times, serif" size="3"> Давайте 
      рассмотрим теперь <a href="../stud/13-4c.htm">программу</a>, расположенную 
      в файле /ftp/pub/sem/sem13-14/13-4.c. Эта программа отличается от программы 
      из пункта 11 тем, что в ней введена обработка сигнала <b><font color="#008000">SIGINT</font></b> 
      пользовательской функцией. Откомпилируйте и запустите эту <a href="../stud/13-3c.htm">программу</a>, 
      проверьте ее реакцию на нажатие клавиш &lt;ctrl&gt; и &lt;c&gt; и на нажатие 
      клавиш &lt;ctrl&gt; и &lt;4&gt; .</font><br>
      &nbsp;<br>
  </li>
  <LI> 
    <p align="JUSTIFY"> <font  face="Times New Roman, Times, serif" size="3" color="#FF0000"><b> 
      <a name="s1314"></a>Модификация предыдущей программы для пользовательской 
      обработки сигналов SIGINT и SIGQUIT.</b></font> <br>
      <br>
    <p align="JUSTIFY"> <font face="Times New Roman, Times, serif" size="3"> 
      Модифицируйте <a href="../stud/13-4c.htm">программу</a> из предыдущего примера 
      так, чтобы она печатала сообщение и об нажатии клавиш &lt;ctrl&gt; и &lt;4&gt;. 
      Используйте одну и ту же функцию для обработки сигналов <b><font color="#008000">SIGINT</font></b> 
      и <b><font color="#008000">SIGQUIT</font></b>. Откомпилируйте и запустите 
      ее, убедитесь в правильной работе. Снимать программу также придется с другого 
      терминала командой <a href="../../man/kill1.htm">kill</a>.<br>
      &nbsp;<br>
      </font> 
  </li>
  <LI> 
    <p align="JUSTIFY"> <font  face="Times New Roman, Times, serif" size="3" color="#FF0000"><b> 
      <a name="s1315"></a>Восстановление предыдущей реакции на сигнал.</b></font> 
      <br>
      <br>
    <p align="JUSTIFY"><font face="Times New Roman, sans-serif, Courier, mono" size="3"> 
      До сиз пор в прмерах мы игнорировали значение, возвращаемое системным вызовом 
      <a href="../../man/signal.htm">signal()</a>. На самом деле этот системный 
      вызов возвращает указатель на предыдущий обработчик сигнала, что позволяет 
      восстанавливать переопределенную реакцию на сигнал. Рассмотрите <a href="../stud/13-5c.htm">пример 
      программы</a>, возвращающей первоначальную реакцию на сигнал <b><font color="#008000">SIGINT</font></b> 
      после 5 пользовательских обработок сигнала, - /ftp/pub/sem/sem13-14/stud/13-5.c, 
      откомпилируйте ее и запустите на исполнение.</font></p>
  </li>
  <LI> 
    <p align="JUSTIFY"> <font  face="Times New Roman, Times, serif" size="3" color="#FF0000"><b> 
      <a name="s1316"></a>Сигналы SIGUSR1 и SIGUSR2. Использование сигналов для 
      синхронизации процессов.</b></font> <br>
      <br>
    <p align="JUSTIFY"> <FONT face="Times New Roman, sans-serif, Courier, mono" size="3">В 
      операционной системе UNIX существует два сигнала, источниками которых могут 
      служить только системный вызов <a href="../../man/kill2.htm">kill()</a> 
      или команда <a href="../../man/kill1.htm">kill</a>, - это сигналы <b><font color="#008000">SIGUSR1</font></b> 
      и <b><font color="#008000">SIGUSR2</font></b>. Обычно их применяют для передачи 
      информации о происшедшем событии от одного пользовательского процесса другому 
      в качестве сигнального средства связи между процессами пользователя. <br>
      <br>
      
      На <a href="../../05/prep/sem5.htm#s0512">семинаре 5</a>, когда мы изучали 
      связь родственных процессов через pipe, мы говорили о том, что pipe является 
      однонаправленным каналом связи, и что для организации связи через один pipe 
      в двух направлениях необходимо использовать механизмы взаимной синхронизации 
      процессов. Организуйте двусторонную поочередную связь процесса-родителя 
      и процесса-ребенка через pipe, используя для синхронизации сигналы <b><font color="#008000">SIGUSR1</font></b> 
      и <b><font color="#008000">SIGUSR2</font></b>, модифицировав <a href="../../05/stud/05-3c.htm">программу</a> 
      /ftp/pub/sem5/stud/05-3.c. <br>
      <br>
      </font><font face="Times New Roman, Times, serif" size="3"><font face="Times New Roman, Times, serif" size="2"><b><u>Задача 
      повышенной сложности:</u></b> организуйте побитовую передачу целого числа 
      между двумя процессами, используя для этого только сигналы <b><font color="#008000">SIGUSR1</font></b> 
      и <b><font color="#008000">SIGUSR2</font></b>.</font></font><FONT face="Times New Roman, sans-serif, Courier, mono" size="3"> 
      <br>
      <br>
      </font><font face="Times New Roman, Times, serif" size="3"> <img border="0" src="../../images/znak.gif" align="left" vspace="2" alt="Nota bene" hspace="10"> 
      При реализации нитей исполнения в операционной системе Linux (<a href="../../06/prep/sem6-7.htm#s0611">см. 
      семинары 6-7</a>) сигналы <b><font color="#008000">SIGUSR1</font></b> и 
      <b><font color="#008000">SIGUSR2</font></b> используются для организации 
      синхронизации между процессами, представляющими нити исполнения, и процессом-координатором 
      в служебных целях. Поэтому пользовательские программы, использующие в своей 
      работе нити исполнения <u><b>не могут использовать сигналы</b></u> <b><font color="#008000">SIGUSR1</font></b> 
      и <b><font color="#008000">SIGUSR2</font></b>.<br>
      &nbsp;<br>
      </font> 
  </li>
  <LI> 
    <p align="JUSTIFY"> <font  face="Times New Roman, Times, serif" size="3" color="#FF0000"><b> 
      <a name="s1317"></a>Завершение порожденного процесса. Системный вызов waitpid(). 
      Сигнал SIGCHLD.</b></font><br>
      <br>
    <p align="JUSTIFY"> <font face="Times New Roman, Times, serif" size="3"> На 
      <a href="../../03/prep/sem3-4.htm">семинарах 3-4</a> при <a href="../../03/prep/sem3-4.htm#s0310">изучении 
      завершения процесса</a>, мы с вами говорили о том, что если процесс-ребенок 
      завершает свою работу прежде процесса-родителя, и процесс-родитель явно 
      не указал, что он не заинтересован в получении информации о статусе завершения 
      процесса-ребенка, то завершившийся процесс не исчезает из системы окончательно, 
      а остается в состоянии <i><b>закончил исполнение</b></i> (зомби-процесс) 
      либо до завершения процесса-родителя, либо до того момента, когда родитель 
      соблаговолит получить эту информацию.<br>
      <br>
      Для получения такой информации процесс-родитель может воспользоваться системным 
      вызовом <a href="../../man/waitpid.htm">waitpid()</a> или его упрощенной 
      формой <a href="../../man/waitpid.htm">wait()</a>. Системный вызов <a href="../../man/waitpid.htm">waitpid()</a> 
      позволяет процессу-родителю синхронно получить данные о статусе завершившегося 
      процесса-ребенка, либо блокируя процесс-родитель до завершения процесса-ребенка, 
      либо без блокировки при его периодическом вызове с опцией <b><font color="#008000">WNOHANG</font></b>. 
      Эти данные занимают 16-бит и, в рамках нашего курса, могут быть расшифрованы 
      следующим образом:<br>
      <br>
      </font> 
    <ul type ="square">
      <li> 
        <p align="JUSTIFY"> <font face="Times New Roman, Times, serif" size="3"> 
          Если процесс завершился при помощи явного или неявного вызова функции 
          <a href="../../man/exit.htm">exit()</a>, то данные выглядят так (старший 
          бит находится слева) </font> 
      </li>
    </ul>
    <p align="center"><img  src="../images/s13-2.jpg" width="394" height="69"> 
      <br>
    <ul type="square">
      <li> 
        <p align="JUSTIFY"> <font face="Times New Roman, Times, serif" size="3"> 
          Если процесс был завершен сигналом, то данные выглядят так (старший 
          бит находится слева)<br>
          </font> 
      </li>
    </ul>
    <p align="center"><img src="../images/s13-3.jpg" width="390" height="109"><br>
    <p align="JUSTIFY"><font face="Times New Roman, Times, serif" size="3">Каждый 
      процесс-ребенок при завершении работы посылает своему процессу-родителю 
      специальный сигнал <b><font color="#008000">SIGCHLD</font></b>, на который 
      у всех процессов по умолчанию установлена реакция &quot;игнорировать сигнал&quot;. 
      Наличие такого сигнала совместно с системным вызовом <a href="../../man/waitpid.htm">waitpid()</a> 
      позволяет организовать асинхронный сбор информации о статусе завершившихся 
      порожденных процессов процессом-родителем.<br>
      <br>
      Используя системный вызов <a href="../../man/signal.htm">signal()</a> мы 
      можем явно установить игнорирование этого сигнала (<b><font color="#008000">SIG_IGN</font></b>), 
      тем самым проинформировав систему, что нас не интересует, каким образом 
      завершатся порожденные процессы. В этом случае зомби-процессов возникать 
      не будет, но и применение системных вызовов <a href="../../man/waitpid.htm">wait()</a> 
      и <a href="../../man/waitpid.htm">waitpid()</a> будет запрещено.<br>
      &nbsp;<br>
      </font> 
  </li>
  <LI> 
    <p align="JUSTIFY"> <font  face="Times New Roman, Times, serif" size="3" color="#FF0000"><b> 
      <a name="s1318"></a>Прогон программы для иллюстрации обработки сигнала SIGCHLD. 
      </b></font> <br>
      <br>
    <p align="JUSTIFY"> <font face="Times New Roman, Times, serif" size="3"> Для 
      закрепления сказанного давайте рассмотрим <a href="../stud/13-6c.htm">пример 
      программы</a> с асинхронным получением информации о статусе завершения порожденного 
      процесса - /ftp/pub/sem/sem13-14/stud/s13-6.c. В этой программе родитель 
      порождает 2 процесса. Один из них завершается с кодом 200, а второй - циклится. 
      Перед порождением процессов родитель устанавливает обработчик прерывания 
      для сигнала <b><font color="#008000">SIGCHLD</font></b>, а после их порождения 
      уходит в бесконечный цикл. В обработчике прерывания вызывается <a href="../../man/waitpid.htm">waitpid()</a> 
      для любого порожденного процесса. Так как в обработчик мы попадаем, когда 
      какой-либо из процессов завершился, то системный вызов не блокируется, и 
      мы можем получить информацию об идентификаторе завершившегося процесса и 
      причине его завершения. Откомпилируйте программу и запустите ее на исполнение. 
      Второй порожденный процесс завершайте с помощью команды <a href="../../man/kill1.htm">kill</a> 
      с каким-либо номером сигнала. Родительский процесс также будет необходимо 
      завершать командой<a href="../../man/kill1.htm"> kill</a>.<br>
      &nbsp;<br>
      </font> 
  </li>
  <LI> 
    <p align="JUSTIFY"> <font  face="Times New Roman, Times, serif" size="3" color="#FF0000"><b> 
      <a name="s1319"></a>Возникновение сигнала SIGPIPE при попытке записи в pipe 
      или FIFO, который никто не собирается читать.</b></font> <br>
      <br>
      <font face="Times New Roman, Times, serif" size="3"> На <a href="../../05/prep/sem5.htm">семинаре 
      5</a> при обсуждении работы с pip'ами и FIFO мы говорили, что для них системные 
      вызовы <a href="../../man/read.htm">read()</a> и <a href="../../man/read.htm">write()</a> 
      имеют определенные <a href="../../man/read.htm#read1">особенности поведения</a>. 
      Одной из таких особенностей является получение сигнала <b><font color="#008000">SIGPIPE</font></b> 
      процессом, который пытается записывать информацию в pipe или в FIFO в том 
      случае, когда читать ее уже некому (нет ни одного процесса, который имеет 
      соответствующий pipe или FIFO открытым для чтения). Реакция по умолчанию 
      на этот сигнал - прекратить работу процесса. Теперь мы с вами уже можем 
      написать корректную обработку этого сигнала пользователем для, например, 
      элегантного прекращения работы пишущего процесса. <img border="0" src="../../images/znak.gif" align="left" vspace="2" alt="Nota bene" hspace="10"> 
      Однако, нам для полноты картины необходимо познакомиться с особенностями 
      поведения некоторых системных вызовов при получении сигналов процессом <u>во 
      время их выполнения</u>.<br>
      <br>
      По ходу нашего курса мы с вами познакомились с рядом системных вызовов, 
      которые могут блокировать процесс во время своего выполнения. К их числу 
      относятся системный вызов <a href="../../man/open.htm">open()</a> при <a href="../../05/prep/sem5.htm#s0515">открытии 
      FIFO</a>, системные вызовы <a href="../../man/read.htm">read()</a> и <a href="../../man/read.htm">write()</a> 
      при <a href="../../05/prep/sem5.htm#s0513">работе с pip'ами и FIFO</a>, 
      системные вызовы <a href="../../man/msgsnd.htm">msgsnd()</a> и <a href="../../man/msgrcv.htm">msgrcv()</a> 
      при <a href="../../09/prep/sem9.htm#s0904">работе с очередями сообщений</a>, 
      системный вызов <a href="../../man/semop.htm">semop()</a> при <a href="../../08/prep/sem8.htm#s0803">работе 
      с семафорами</a> и т.д. Что произойдет с процессом, если он, выполняя один 
      из этих системных вызовов, получит какой-либо сигнал. Дальнейшее поведение 
      процесса зависит от установленной для него реакции на этот сигнал. <br>
      <br>
      </font> 
    <dir> 
      <ul type = "square">
        <li> 
          <p align="JUSTIFY"> <font face="Times New Roman, Times, serif" size="3"> 
            Если реакция на полученный сигнал была &quot;игнорировать сигнал&quot; 
            (независимо от того, установлена она по умолчанию или пользователем 
            с помощью системного вызова <a href="../../man/signal.htm">signal()</a>), 
            то поведение процесса не изменится. </font> 
        </li>
        <li> 
          <p align="JUSTIFY"> <font face="Times New Roman, Times, serif" size="3"> 
            Если реакция на полученный сигнал установлена по умолчанию и заключается 
            в прекращении работы процесса, то процесс перейдет в состояние <b><i>закончил 
            исполнение</i></b>. </font> 
        </li>
        <li> 
          <p align="JUSTIFY"> <font face="Times New Roman, Times, serif" size="3"> 
            Если реакция процесса на сигнал заключается в выполнении пользовательской 
            функции, то процесс выполнит эту функцию (если он находился в состоянии 
            <i><b>ожидание</b></i>, он перейдет в состояние <b><i>готовность </i></b>и 
            затем в состояние <i><b>исполнение</b></i>) и вернется из системного 
            вызова с констатацией ошибочной ситуации. Отличить такой возврат от 
            действительно ошибочной ситуации можно с помощью значения системной 
            переменной <b><font color="#008000">errno</font></b>, которая в этом 
            случае примет значение <font color="#008000">EINTR</font>.</font><br>
            <br>
        </li>
      </ul>
    </dir>
    <p align="JUSTIFY"> <font face="Times New Roman, Times, serif" size="3"> После 
      этого краткого обсуждения становится до конца ясно, как корректно обработать 
      ситуацию "никто не хотел прочитать" для системного вызова <a href="../../man/read.htm">write()</a>. 
      Чтобы пришедший сигнал <b><font color="#008000">SIGPIPE</font></b> не завершил 
      работу нашего процесса по умолчанию, мы должны его самостоятельно обработать 
      (функция-обработчик при этом может быть и пустой!). Но этого мало. Поскольку 
      нормальный ход выполнения системного вызова был нарушен сигналом, мы вернемся 
      из него с отрицательным значением, которое свидетельствует об ошибке. Проанализировав 
      значение системной переменной<b><font color="#008000"> errno</font></b> 
      на предмет совпадения с значением<b><font color="#008000"> EINTR</font></b>, 
      мы можем отличить возникновение сигнала <b><font color="#008000">SIGPIPE</font></b> 
      от других ошибочных ситуаций (неправильные значения параметров и т.д.) и 
      грациозно продолжить работу программы.<br>
      &nbsp;<br>
      </font> 
  </li>
  <LI> 
    <p align="JUSTIFY"> <font  face="Times New Roman, Times, serif" size="3" color="#FF0000"><b> 
      <a name="s1320"></a>Понятие о надежности сигналов. POSIX функции для работы 
      с сигналами.</b></font> <br>
      <br>
    <p align="JUSTIFY"> <font face="Times New Roman, Times, serif" size="3"> Основным 
      недостатком системного вызова <a href="../../man/signal.htm">signal()</a> 
      является его низкая надежность. <br>
      <br>
      Во многих вариантах операционной системы UNIX установленная при его помощи 
      обработка сигнала пользовательской функцией выполняется только один раз, 
      после чего автоматически восстанавливается реакция на сигнал по умолчанию. 
      Для постоянной пользовательской обработки сигнала необходимо каждый раз 
      заново устанавливать реакцию на сигнал прямо внутри функции-обработчика.<br>
      <br>
      В системных вызовах и пользовательских программах могут существовать критические 
      участки, на которых процессу недопустимо отвлекаться на обработку&nbsp;сигналов. 
      Мы можем выставить на этих участках реакцию &quot;игнорировать сигнал&quot; 
      с последующим восстановлением предыдущей реакции, но если сигнал все-таки 
      возникнет на критическом участке, то информация об его возникновении будет 
      безвозвратно потеряна. <br>
      <br>
      Наконец, последний недостаток связан с невозможностью определить сколько 
      сигналов одного и того же типа поступило процессу пока он находился в состоянии 
      <i> <b>готовность</b></i>. Сигналы одного типа не ставятся в очередь! Процесс 
      может узнать о том, что сигнал или сигналы определенного типа были ему переданы, 
      но не может определить их количество. Эту черту мы можем проиллюстрировать, 
      слегка изменив <a href="../stud/13-6c.htm">программу с асинхронным получением 
      информации о статусе завершившихся процессов</a>, рассмотренную нами <a href="#s1318">ранее</a>. 
      Пусть в <a href="../stud/13-7c.htm">новой программе </a>процесс-родитель 
      порождает в цикле пять новых процессов, каждый из которых сразу же завершается 
      со своим собственным кодом, после чего уходит в бесконечный цикл (файл /fnp/pub/sem/sem13-14/stud/s13-7.c). 
      Сколько сообщений о статусе завершившихся детей мы ожидаем получить? Пять! 
      А сколько получим? It depends... Откомпилируйте, прогоните и посчитайте. 
      <br>
      <br>
      Последующие версии System Y и BSD пытались устранить эти недостатки своими 
      собственными средствами. Единый способ более надежной обработки сигналов 
      появился с введением POSIX стандарта на системные вызовы UNIX. Набор функций 
      и ситемных вызовов для работы с сигналами был существенно расширен и построен 
      таким образом, что позволял временно блокировать обработку определенных 
      сигналов, не допуская их потери. Однако проблема, связанная с определением 
      количества пришедших сигналов одного типа, по-прежнему остается проблемой. 
      (Надо отметить, что подобная проблема существует на аппаратном уровне и 
      для внешних прерываний. Процессор зачастую не может определить, какое количество 
      внешних прерываний с одним номером возникло, пока он выполнял очередную 
      команду.) <br>
      <br>
      Рассмотрение POSIX сигналов выходит за рамки нашего курса. Желающие могут 
      самостоятельно посмотреть описания функций и системных вызовов <FONT face="Times New Roman, sans-serif, Courier, mono" size="3"><i>sigemptyset(), 
      sigfillset(), sigaddset(), sigdelset(), sigismember(), sigaction(), sigprocmask(), 
      sigpending(), sigsuspend()</i></font> в UNIX Manual.<br>
      <br>
      </font><font face="Times New Roman, Times, serif" size="3"><font face="Times New Roman, Times, serif" size="2"><b><u>Задача 
      повышенной сложности:</u></b> Модифицируйте обработку сигнала в программе 
      <a href="../stud/13-7c.htm">/ftp/pub/sem/sem13-14/stud/13-7.c</a>, не применяя POSIX сигналы, так, чтобы 
      процесс-родитель все-таки сообщал о статусе всех завершившихся детей.</font></font><FONT face="Times New Roman, sans-serif, Courier, mono" size="3"> 
      <br>
      </font> 
  </li>
</ol>



  
<P align="center"><a href="../../11/prep/sem11-12.htm"> Предыдущий семинар</a> 
  | <a href="../../os.html">Программа курса</a> <a href="../../15/prep/sem15-16.htm"> Следующий семинар</a></P>
</BODY>
</HTML>
