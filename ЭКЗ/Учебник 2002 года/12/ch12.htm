<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
<TITLE>Глава 12</TITLE>
</HEAD>
<body bgcolor="#FFFFFF">
 <basefont face="Times New Roman, sans-serif, Courier, mono" size="3">
<p style='text-align:center'><b><font size="4">
Глава 12.  Реализация файловой системы</font></b></p>

<p align="center"><a href="../11/ch11.htm"> Предыдущая глава</a> | 
<a href="../os.html">Программа курса</a> | 
<a href="../13/ch13.htm"> Следующая глава</a></p>


<p style='text-align:justify'><b><font face="Times New Roman,sans-serif,Courier,mono" ,size="3" size="3">
<a name="l1201">12.1 Интерфейс файловой системы.</a></font></b></p>
<p style='text-align:justify'>Как уже говорилось,  файловая система должна организовать
  эффективную работу с данными, хранящимися во внешней памяти и предоставить пользователю
  возможности для запоминания и выборки данных в нем.</p>
<p style='text-align:justify'>Для организации хранения информации на диске пользователь
  вначале обычно выполняет его форматирование, выделяя на нем место для структур
  данных, которые описывают состояние файловой системы в целом. Затем  пользователь
  создает нужную ему структуру каталогов (или директорий), которые по существу
  являются списками вложенных каталогов и собственно файлов. И, наконец, заполняет
  дисковое пространство  файлами, приписывая их тому или иному каталогу. Таким
  образом,  ОС должна предоставить в распоряжение пользователя совокупность сервисов
  традиционно реализованных через системные вызовы, которые обеспечивают:</p>
<ul>
  <li>
    <p style="text-align:justify">создание файловой системы на диске</li>
  <li>
    <p style="text-align:justify">необходимые операции для работы с каталогами</li>
  <li>
    <p style="text-align:justify">необходимые операции для работы с файлами</li>
</ul>
<p style='text-align:justify'>Кроме того, файловые службы могут решать проблемы
  проверки и сохранения целостности файловой системы, проблемы повышения производительности
  и ряд других.</p>
<p style='text-align:justify'>Прежде чем приступить к описанию работы отдельных
  файловых операций, необходимо рассмотреть ключевые алгоритмы и структуры данных,
  которые обеспечивают функционирование файловой системы.  </p>
<p style='text-align:justify'><b><font face="Times New Roman,sans-serif,Courier,mono" ,size="3">
<a name="l1202">12.2 Общая структура файловой системы</a></font></b></p>
<p align="justify">Система хранения данных на дисках
  может быть структурирована следующим образом (см. рис. 12.1). </p>
<p align="justify"><i>Нижний уровень</i> - оборудование.
  Это в первую очередь,  магнитные диски с подвижными головками - основные устройства
  внешней памяти, представляющие собой пакеты магнитных пластин (поверхностей),
  между которыми на одном рычаге двигается пакет магнитных головок. Шаг движения
  пакета головок является дискретным и каждому положению пакета головок логически
  соответствует цилиндр магнитного диска. Цилиндры делятся на дорожки (треки),
  а каждая дорожка размечается на одно и то же количество блоков (секторов), таким
  образом, что в каждый блок можно записать по максимуму одно и то же число байтов.
  Следовательно,  для произведения обмена с магнитным диском на уровне аппаратуры
  нужно указать номер цилиндра, номер поверхности, номер блока на соответствующей
  дорожке и число байтов, которое нужно записать или прочитать от начала этого
  блока.  Таким образом,  диски могут быть разбиты на блоки фиксированного размера,
  и можно  непосредственно получить доступ к любому блоку  (организовать прямой
  доступ к файлам).</p>
<p align="justify">Непосредственно с устройствами
  (дисками) взаимодействует  часть ОС, называемая <b> </b><i>система ввода-вывода</i>
  (см. соответствующую главу). Система ввода-вывода (она состоит из драйверов
  устройств и обработчиков прерываний для передачи информации между памятью и
  дисковой системой)  предоставляет в распоряжение более высокоуровневого компонента
  ОС  - файловой системы используемое дисковое пространство в виде <i>непрерывной
  последовательности блоков фиксированного размера</i>. Система ввода-вывода
  имеет дело с <i>физическими</i>  блоками диска, которые характеризуются адресом,
  например,  диск 2, цилиндр 75, сектор 11. Файловая система имеет дело с <i>логическими</i>
  блоками, каждый из которых имеет номер (от 0 или 1 до <font face="Times New Roman,sans-serif,Courier,mono",size="3">N</font>).
  Размер этих логических блоков файла совпадает или кратен размеру физического
  блока диска и может быть задан равным размеру страницы виртуальной памяти, поддерживаемой
  аппаратурой компьютера совместно с операционной системой. </p>
<p align="justify">В структуре системы управления
  файлами можно выделить  <i>базисную</i> подсистему, которая отвечает за выделение
  дискового пространства  конкретным файлам,  и более высокоуровневую <i>логическую</i>
  подсистему, которая  использует структуру дерева  директорий для  предоставления
  модулю базисной подсистемы необходимой ей информации исходя из символического
  имени файла. Она также ответственна за  авторизацию доступа к файлам (см. главу
  Безопасность ОС).</p>
<p style='text-align:justify'><img border="0" src="images/image001.gif" width="621" height="735"></p>
<p style='text-align:justify'>                              
<font size="2">Рис. 12.1 Блок схема
  файловой системы</font></p>
<p align="justify">В современных ОС далее принято
  разбивать диски на <i>логические диски</i> (это также низкоуровневая операция),
  иногда называемые  <i>разделами</i> (<font face="Times New Roman,sans-serif,Courier,mono",size="3">partitions</font>).  Бывает,
  что  наоборот объединяют несколько физических дисков в один логический диск
  (например, как это можно сделать в ОС <font face="Times New Roman,sans-serif,Courier,mono",size="3">Windows</font><font face="Times New Roman,sans-serif,Courier,mono",size="3"> </font><font face="Times New Roman,sans-serif,Courier,mono",size="3">NT</font>). На каждом разделе можно иметь
  свою независимую файловую систему. Поэтому в дальнейшем изложении мы будем игнорировать
  проблему физического выделения пространства для файлов и считать, что каждый
  раздел представляет  собой  отдельный (виртуальный) диск.  Собственно диск
  содержит иерархическую древовидную структуру, состоящую из набора файлов, каждый
  из которых является хранилищем данных пользователя, и каталогов  или директорий
  (то есть файлов, которые содержат перечень  других файлов, входящих в состав
  каталога), которые необходимы для хранения информации о файлах системы. </p>
<p align="justify"><i>Стандартный запрос</i> на открытие (<font face="Times New Roman,sans-serif,Courier,mono",size="3">open</font>) 
  или создание (<font face="Times New Roman,sans-serif,Courier,mono",size="3">creat</font>) 
  файла поступает от прикладной программы к логической подсистеме. Логическая 
  подсистема, используя структуру директорий, проверяет права доступа и вызывает 
  базовую подсистему для получения доступа к блокам файла. После этого файл считается 
  открытым, содержится в таблице открытых файлов, прикладная программа получает 
  в свое распоряжение дескриптор (или <font face="Times New Roman,sans-serif,Courier,mono",size="3">handle</font> 
  в системах <font face="Times New Roman,sans-serif,Courier,mono",size="3">Microsoft</font>)  
  этого файла.  Дескриптор файла является ссылкой на файл в таблице открытых файлов 
  и используется в запросах прикладной программы на чтение-запись из этого файла. 
  Запись в таблице открытых файлов указывает  через систему аллокации блоков диска 
  на блоки данного файла.  Если к моменту открытия файл уже используется другим 
  процессом, то есть содержится в таблице открытых файлов, то, после проверки 
  прав доступа к файлу может быть организован совместный доступ. При  этом новому 
  процессу также возвращается дескриптор - ссылка  на файл в таблице открытых 
  файлов. Далее в тексте подробно проанализирована работа наиболее важных системных 
  вызовов.</p>
<p style='text-align:justify'><b><font face="Times New Roman,sans-serif,Courier,mono",size="3">
<a name="l1203">12.3 Структура файловой системы на диске.</a></font></b></p>
<p style='text-align:justify'>Прежде чем  рассмотреть структуру данных файловой
  системы на диске необходимо рассмотреть алгоритмы выделения дискового пространства
  и способы учета свободной и занятой дисковой памяти.</p>
<p style='text-align:justify'><b>
<a name="l120301">12.3.1  Методы выделения дискового пространства</a></b></p>
<p align="justify">Ключевой вопрос  реализации 
  способ связывания файлов с блоками диска. В ОС используется несколько методов
  выделения файлу дискового пространства. Для каждого метода сведения о локализации
  блоков данных файла можно извлечь из записи в директории, соответствующей символьному
  имени файла.</p>
<p align="justify"><i><font face="Times New Roman,sans-serif,Courier,mono",size="3">Выделение
  непрерывной последовательностью блоков</font></i></p>
<p align="justify">Простейший способ - хранить каждый
  файл, как непрерывную последовательность  блоков диска. При непрерывном расположении
  файл характеризуется адресом и длиной (в блоках). Файл,  стартующий с блока
  b, занимает затем блоки b+1, b+2, ... b+n-1. </p>
<p align="justify">Эта схема имеет два преимущества.
  Во-первых,  ее легко реализовать, т.к. выяснение местонахождения файла сводится
  к вопросу,  где находится первый блок. Во-вторых, она обеспечивает хорошую
  производительность, т.к. целый файл может быть считан за одну дисковую операцию.</p>
<p align="justify">Непрерывное выделение используется
  в ОС IBM/CMS, в ОС <font face="Times New Roman,sans-serif,Courier,mono",size="3">RSX</font>-11 (для выполняемых файлов) и
  в ряде других.</p>
<p align="justify">Основная  проблема, вследствие чего этот способ мало распространен  
  - трудно найти место для нового файла. В процессе эксплуатации  диск представляет 
  собой некоторую совокупность свободных и занятых фрагментов. Проблема непрерывного 
  расположения может рассматриваться как частный случай более общей проблемы выделения 
  n блоков из списка свободных дыр.  Наиболее  распространенные стратегии решения 
  этой проблемы - first fit, best fit и <font face="Times New Roman,sans-serif,Courier,mono",size="3">worst</font><font face="Times New Roman,sans-serif,Courier,mono",size="3"> 
  </font><font face="Times New Roman,sans-serif,Courier,mono",size="3">fit</font> 
  (ср. с проблемой выделения памяти). Таким образом,  метод страдает от <i>внешней 
  фрагментации</i>, в зависимости от размера диска и среднего размера файла,  
  в большей или меньшей степени. </p>
<p align="justify">Кроме того, непрерывное распределение
  внешней памяти не применимо до тех пор, пока не известен максимальный  размер
  файла.  Иногда размер выходного файла оценить легко (при копировании). Чаще,
  однако, это трудно сделать. Если места не хватило, то пользовательская программа
  может быть приостановлена, предполагая выделение дополнительного места для файла
  при последующем рестарте. Некоторые ОС используют модифицированный вариант непрерывного
  выделения  основные блоки файла + резервные блоки. Однако с выделением блоков
  из резерва возникают те же проблемы,  так как возникает задача выделения непрерывной
  последовательности блоков диска теперь уже из совокупности резервных блоков.
</p>
<p align="justify"><i><font face="Times New Roman,sans-serif,Courier,mono",size="3">Связный список</font></i></p>
<p align="justify">Метод  распределения блоков в
  виде связного списка решает основную проблему непрерывного выделения, то есть
  устраняет внешнюю фрагментацию.  Каждый файл - связный список блоков диска.
  Запись в директории содержит указатель на первый и последний блоки файла. Каждый
  блок содержит указатель на следующий блок. </p>
<p align="justify"><img border="0" src="images/image002.gif" width="606" height="170"></p>
<p align="left"><font size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Рис. 12.2  Хранение файла в виде
  связного списка дисковых блоков</font></p>
<p align="justify">Внешняя фрагментация для данного
  метода отсутствует. Любой свободный блок может быть использован для удовлетворения
  запроса. Заметим, что нет необходимости декларировать размер файла в момент
  создания. Файл может неограниченно расти. </p>
<p align="justify">Связное выделение имеет, однако,
  несколько существенных недостатков. </p>
<p align="justify">Во-первых, при прямом доступе
  к файлу для поиска i-го блока нужно осуществить несколько обращений к диску,
  последовательно считывая блоки от 1 до <font face="Times New Roman,sans-serif,Courier,mono",size="3">i</font>-1, то есть
  выборка логически  смежных записей, которые  занимают  физически  несмежные
  секторы, может  требовать много времени.  </p>
<p align="justify">Прямым следствием этого является
  <i>низкая надежность</i>.  Наличие дефектного блока в списке приводит к потере
  информации в остаточной части файла и, потенциально, к потере дискового пространства
  отведенного под этот файл.</p>
<p align="justify">Наконец,  для указателя на следующий
  блок внутри блока нужно выделить место. Емкость блока, традиционно являющаяся
  степенью двойки (многие программы читают и пишут блоками по степеням двойки),
  таким образом,  перестает быть степенью двойки, т.к. указатель отбирает несколько
  байтов. </p>
<p style='text-align:justify'>Поэтому метод связного списка обычно не используется
  в чистом виде.</p>
<p style='text-align:justify'><i><font face="Times New Roman,sans-serif,Courier,mono" ,size="3">Связный список
  с использованием индекса</font></i></p>
<p align="justify">Недостатки предыдущего способа
  могут быть устранены путем изъятия указателя из каждого дискового блока и помещения
  его в индексную таблицу в памяти, которая называется <font face="Times New Roman,sans-serif,Courier,mono",size="3">FAT</font> (<font face="Times New Roman,sans-serif,Courier,mono",size="3">file</font><font face="Times New Roman,sans-serif,Courier,mono",size="3"> </font><font face="Times New Roman,sans-serif,Courier,mono",size="3">allocation</font><font face="Times New Roman,sans-serif,Courier,mono",size="3"> </font><font face="Times New Roman,sans-serif,Courier,mono",size="3">table</font>).  Этой схемы придерживаются многие ОС (<font face="Times New Roman,sans-serif,Courier,mono",size="3">MS</font>-<font face="Times New Roman,sans-serif,Courier,mono",size="3">DOS</font>, <font face="Times New Roman,sans-serif,Courier,mono",size="3">OS</font>/2,
  <font face="Times New Roman,sans-serif,Courier,mono",size="3">MS</font><font face="Times New Roman,sans-serif,Courier,mono",size="3"> </font><font face="Times New Roman,sans-serif,Courier,mono",size="3">Windows</font> и др.)</p>
<p align="justify"><img border="0" src="images/image003.gif" width="232" height="447"></p>
<p align="justify"><font size="2">Рис. 12.3.  Метод связного списка,
  с использованием таблицы в оперативной памяти</font></p>
<p align="justify">По-прежнему,  существенно, что
  запись в директории  содержит только ссылку на первый блок и т.о.  можно локализовать
  файл независимо от его размера. </p>
<p align="justify">Минусом этой схемы может быть
  необходимость поддержки в памяти этой довольно большой таблицы. </p>
<p style='text-align:justify'><i><font face="Times New Roman,sans-serif,Courier,mono" ,size="3">Индексные узлы</font></i><i><font face="Times New Roman,sans-serif,Courier,mono",size="3"></font></i></p>
<p align="justify">Четвертый и последний метод  выяснения принадлежности блока 
  к файлу - связать с каждым файлом маленькую таблицу, <a href="../11/prep/sem11-12.htm#s1104">
<img src="../images/computer.gif" width="48" height="48" align="right"  alt="Материалы семинарских занятий"  border="0"></a>называемую 
  индексным узлом (i-node), которая  перечисляет атрибуты и дисковые адреса блоков 
  файла (см. рис 12.4).  </p>
<p align="justify">Каждый файл имеет свой собственный
  индексный блок,  который содержит адреса блоков данных.  Запись в директории,
  относящаяся к файлу, содержит адрес индексного блока.  По мере заполнения файла
  указатели на блоки диска в индексном узле принимают осмысленные значения.</p>
<p align="justify">Индексирование поддерживает прямой
  доступ к файлу, без ущерба от внешней фрагментации.</p>
<p align="justify"><img border="0" src="images/image004.gif" width="555" height="590"></p>
<p>                       
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size="2">&nbsp;Рис.
  12.4  Структура индексного узла</font></p>
<p align="justify">Первые несколько адресов блоков
  файла хранятся непосредственно в индексном узле, т.о. для маленьких файлов
  индексный узел хранит всю необходимую  информацию, которая копируется с диска
  в память,  в момент открытия файла. Для больших файлов один из адресов  индексного
  узла  указывает на блок косвенной адресации.  Этот блок содержит  адреса дополнительных
  блоков диска.  Если этого недостаточно используется  блок двойной косвенной
  адресации, который содержит адреса блоков косвенной адресации. Если и этого
  недостаточно используют блок тройной косвенной адресации. </p>
<p align="justify"><font face="Times New Roman,sans-serif,Courier,mono" ,size="3">Эту
  схему использует Un</font><font face="Times New Roman,sans-serif,Courier,mono" ,size="3">ix</font> (а также  файловые системы <font face="Times New Roman,sans-serif,Courier,mono",size="3">HPFS</font><font face="Times New Roman,sans-serif,Courier,mono",size="3">, </font><font face="Times New Roman,sans-serif,Courier,mono",size="3">NTFS</font> и др.). Такой подход позволяет
  при фиксированном, относительно небольшом размере индексного узла,  поддерживать
  работу с файлами, размер которых может меняться от нескольких байт до нескольких
  гигабайт.  Существенно, что для маленьких файлов используется только прямая
  адресация, обеспечивающая максимальную производительность.</p>
<p style='text-align:justify'><a name="_Toc496007890"></a><a name="l120302"><b>
<font face="Times New Roman,sans-serif,Courier,mono",size="3">12.3.2</font></b></a><b><font face="Times New Roman,sans-serif,Courier,mono",size="3"> 
Управление свободным и занятым дисковым пространством.
  </font></b></p>
<p align="justify"><font face="Times New Roman,sans-serif,Courier,mono",size="3">В
  современных ОС используется несколько способов учета используемого места на
  диске. Рассмотрим наиболее распространенные.</font></p>
<p align="justify"><i><font face="Times New Roman,sans-serif,Courier,mono",size="3">Учет
  при помощи организации битового вектора.</font></i></p>
<p align="justify">Часто список свободных блоков диска реализован  в виде битового 
  вектора (bit map или bit vector). Каждый блок представлен одним битом, принимающим 
  значение 0 или 1,  в зависимости от того занят он или свободен. Например,   
  00111100111100011000001 ....</p>
<p align="justify">Главное преимущество этого подхода - он относительно прост 
  и эффективен при нахождении первого свободного блока, или n последовательных 
  блоков на диске.  Многие компьютеры имеют инструкции манипулирования битами, 
  которые могут быть использованы для этой цели. Например, компьютеры семейств 
  Intel и Motorola имеют инструкции, которые при помощи которых можно легко локализовать 
  первый единичный бита в слове.  </p>
<p align="justify">Описываемый метод учета свободных
  блоков используется в Apple Macintosh.</p>
<p align="justify">К сожалению,  этот метод  эффективен,
  только если битовый вектор помещается в памяти целиком,  что возможно только
  для относительно небольших дисков. Например, диск размером 1.3 Гб  с блоками
  по  512 байт нуждается в  таблице размером 332К для управления свободными блоками.
</p>
<p align="justify"><i><font face="Times New Roman,sans-serif,Courier,mono",size="3">Учет
  при помощи организации связного списка.</font></i></p>
<p align="justify"><a name="_Toc495916156">Другой
  подход - связать в  список все свободные блоки,  поддерживая указатель на первый
  свободный блок в специальном месте диска, попутно кэшируя в памяти эту информацию.</a></p>
<p align="justify">Эта схема  не всегда эффективна.
  Для трассирования списка нужно сделать много обращений к диску. Однако к счастью
  нам необходим, как правило, только первый  свободный блок.<b><font face="Times New Roman,sans-serif,Courier,mono",size="3"></font></b></p>
<p align="justify">Иногда прибегают к модификаци<b>и</b>
  подхода связного списка, организуя хранение адресов n свободных блоков в первом
  свободном блоке. Первые n-1 этих блоков действительно используются. Последний
  блок содержит адр<a
name="_Toc495916157">еса других n блоков. И т.д. </a></p>
<p align="justify"><b><font face="Times New Roman,sans-serif,Courier,mono",size="3">
<a name="l120303">12.3.3 Размер блока </a></font></b></p>
<p align="justify">Размер логического блока играет
  важную роль. В некоторых системах (<font face="Times New Roman,sans-serif,Courier,mono",size="3">Unix</font>) он может быть
  задан при форматировании.   Небольшой размер блока будет приводить к тому, что
  каждый файл будет содержать много блоков.  Чтение блока осуществляется с задержками
  на поиск и вращение, т.о. файл из многих блоков будет читаться медленно. Большие
  блоки обеспечивают более высокую скорость обмена с диском, но вследствие внутренней
  фрагментации (каждый файл занимает целое число блоков и в среднем половина последнего
  блока пропадает) снижается процент полезного дискового пространства.</p>
<p align="justify">В системах со страничной организацией
  памяти имеется  сходная проблема с размером страницы.</p>
<p align="justify">Проведенные исследования показали, что большинство файлов имеет 
  небольшой размер  (в Unix приблизительно 85% файлов имеют размер менее 8 Кбайт 
  и 48% - менее 1Кбайта). </p>
<p align="justify"><img border="0" src="images/image005.gif" width="512" height="384"> </p>
<p align="justify"><font face="Times New Roman,sans-serif,Courier,mono",size="3">
  </font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<font size="2">Рис. 12.5.  Определение оптимального размера блока.</font></p>
<p align="justify">На рис. 12.5 изображены две кривые: одна убывающая  показывает  
  степень утилизации диска (в процентах) с возрастанием размера блока, а вторая 
  возрастающая скорость считывания информации. Они пересекаются в районе 3К. Обычный 
  компромисс   выбор блока размером 512 б, 1К, 2К.</p>
<p align="justify"><b>
<a name="l120304">12.3.4  Структура файловой системы на диске </a></b></p>
<p align="justify">Рассмотрение методов работы с
  дисковым пространством дает общее представление о совокупности служебных данных,
  необходимых для описания файловой системы.  Структуры данных типовой файловой
  системы, например <font face="Times New Roman,sans-serif,Courier,mono",size="3">Unix</font>, на одном из разделов диска, таким образом, может состоять
  из 4-х основных частей:</p>
<p align="justify"><img border="0" src="images/image006.gif" width="648" height="136"></p>
<p align="justify"><font size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Рис. 12.6 Примерная структура
  файловой системы на диске.</font></p>
<p align="justify">В начале раздела находится <b><i>суперблок</i></b>,
  содержащий общее описание файловой системы, например:</p>
<ul type=disc>
  <li style='text-align:justify;     '>Тип файловой системы</li>
  <li style='text-align:justify;     '>Размер файловой системы в блоках<a href="../11/prep/sem11-12.htm#s1106"><img src="../images/computer.gif" width="48" height="48" align="right"  alt="Материалы семинарских занятий" border="0" ></a></li>
  <li style='text-align:justify;     '>Размер массива индексных узлов</li>
  <li style='text-align:justify;     '>Размер логического блока</li>
  <li style='text-align:justify;     '>И.т. д.</li>
</ul>
<p align="justify">Описанные структуры данных создаются
  на диске в результате его <b>форматирования</b> (например,  утилитами <font face="Times New Roman,sans-serif,Courier,mono",size="3">format</font>,
  <font face="Times New Roman,sans-serif,Courier,mono",size="3">makefs</font> и др.).  Их наличие позволяет обращаться к данным
  на диске как к файловой системе, а не как к  обычной последовательности блоков.</p>
<p style='
text-align:justify'>В файловых системах современных ОС для повышения устойчивости
  поддерживается несколько копий суперблока. В некоторых версиях <font face="Times New Roman,sans-serif,Courier,mono",size="3">Unix</font>
  суперблок включал также и структуры данных, управляющие распределением дискового
  пространства, в результате чего суперблок непрерывно подвергался модификации,
  что снижало надежность файловой системы в целом. Выделение структур данных,
  описывающих дисковое пространство, в отдельную часть является более правильным
  решением.</p>
<p style='
text-align:justify'>Массив  индексных узлов (ilist) содержит список  индексов,
  соответствующих файлам данной файловой системы. Размер  массива индексных узлов
  определяется администратором при установке системы. Максимальное число файлов,
  которые могут быть созданы в файловой системе, определяется числом доступных
  индексных узлов. </p>
<p style='
text-align:justify'>В блоках данных хранятся реальные данные файлов. Размер логического
  блока данных может задаваться при форматировании файловой системы. Заполнение
  диска содержательной информацией  предполагает использование блоков хранения
  данных для файлов директорий и обычных файлов и имеет следствием модификацию
  массива индексных узлов и данных, описывающих  пространство диска.  Отдельно
  взятый блок данных может принадлежать одному и только одному файлу в файловой
  системе. <font face="Times New Roman,sans-serif,Courier,mono",size="3"></font></p>
<p style='text-align:justify'><a name="_Toc496007882"><b><font face="Times New Roman,sans-serif,Courier,mono",size="3">
<a name="l1204">12.4  Реализация директорий</a></font></b></a><b><font face="Times New Roman,sans-serif,Courier,mono",size="3"></font></b></p>
<p align="justify">Как уже говорилось, директория
  или каталог  это файл, имеющий определенный тип и хранящий список входящих
  в него файлов или каталогов. Основная задача файлов-директорий  поддержка
  иерархической древовидной структуры файловой системы.  Запись в директории имеет
  определенный для данной ОС формат, зачастую неизвестный пользователю, поэтому
  блоки данных файла-директории заполняются не через операции записи, а при помощи
  специальных системных вызовов (например, создание файла).</p>
<p align="justify">Для доступа к файлу  ОС использует
  путь (<font face="Times New Roman,sans-serif,Courier,mono",size="3">pathname</font>), сообщенный  пользователем. Запись в
  директории  связывает имя файла или имя поддиректории с блоками данных на диске.
  В зависимости от системы эта ссылка может быть дисковым адресом целого файла
  (непрерывное расположение), номером первого блока (связанный список), или номером
  индексного узла.  Во всех случаях главная функция системы директорий - трансформировать
  символьное имя файла в информацию, необходимую, чтобы найти данные.  </p>
<p align="justify">Отдельная проблема  способ хранения
  атрибутов файла.  Иногда их хранят непосредственно в записи в директории.  Для
  системы с индексными узлами можно хранить атрибуты в индексном узле, а не в
  записи в директории.  Как мы увидим позже,  этот метод имеет ряд преимуществ
  при организации совместного доступа к файлам.</p>
<p align="justify"><font face="Times New Roman,sans-serif,Courier,mono",size="3">Рассмотрим
  несколько конкретных примеров.</font></p>
<p align="justify"><b><font face="Times New Roman,sans-serif,Courier,mono",size="3">
<a name="l120401">12.4.1 Примеры реализация директорий в некоторых ОС </a></font></b></p>
<p align="justify">Директории в ОС CP/M</p>
<p align="justify"><font face="Times New Roman,sans-serif,Courier,mono",size="3">В
  ОС CP/M только одна директория.</font></p>
<p align="justify">Каждая запись - строка содержит
  следующие поля: идентификатор собственника, имя файла,  тип файла, поле  <font face="Times New Roman,sans-serif,Courier,mono",size="3">e</font>xtent, которое показывает,
  хватит ли для идентификации файла одной строки или нужны еще, число блоков,
  номера блоков. То есть адреса всех блоков файла перечислены в записи в директории!</p>
<p align="justify">Директории в ОС  MS-DOS</p>
<p align="justify"><font face="Times New Roman,sans-serif,Courier,mono",size="3">В
  ОС </font><font face="Times New Roman,sans-serif,Courier,mono",size="3">MS</font><font face="Times New Roman,sans-serif,Courier,mono",size="3">-</font><font face="Times New Roman,sans-serif,Courier,mono",size="3">DOS</font><font face="Times New Roman,sans-serif,Courier,mono",size="3">  </font>типовая
  запись в директории имеет вид:</p>
<p align="justify"><img border="0" src="images/image007.gif" width="685" height="109"></p>
<p align="justify">
  <font size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  Рис. 12.7  Вариант записи в директории <font face="Times New Roman,sans-serif,Courier,mono",size="3">MS</font>-<font face="Times New Roman,sans-serif,Courier,mono",size="3">DOS</font></font></p>
<p align="justify">В  ОС MS-DOS, как и в большинстве
  современных ОС, директории могут содержать  поддиректории (специфицируемые битом
  атрибута), что позволяет конструировать произвольное дерево директорий файловой
  системы.</p>
<p align="justify">Номер первого блока используется
  в качестве индекса в таблице <font face="Times New Roman,sans-serif,Courier,mono",size="3">FAT</font> . Далее по цепочке могут быть найдены  остальные блоки.</p>
<p align="justify"><a name="_Toc496007885">Директории
  в ОС Unix</a></p>
<p align="justify">Структура директории  проста.
  Каждая  запись содержит имя файла и номер его индексного узла. Вся остальная
  информация о файле (тип, размер, времен модификации, владелец  и т. д. и номера
  дисковых  блоков) находится в индексном узле.</p>
<p align="justify"><img border="0" src="images/image008.gif" width="349" height="95"></p>
<p align="justify"><font size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Рис. 12.8  Вариант
  записи в директории <font face="Times New Roman,sans-serif,Courier,mono",size="3">Unix</font></font></p>
<p style='text-align:justify'><b>
<a name="l120402">12.4.2 Поиск в директории</a></b><b><font face="Times New Roman,sans-serif,Courier,mono",size="3"></font></b></p>
<p style='text-align:justify'>Итак,  директория - есть файл, имеющий специальный
  формат, состоящий из записей фиксированной длины, где каждая запись соответствует
  одному из обычных файлов или директорий, входящих в состав данной директории.
  Как правило, список файлов в директории оказывается не упорядоченным по именам
  файлов. Поэтому правильный выбор алгоритма поиска имени файла в директории имеет
  большое влияние на эффективность и надежность файловых систем. </p>
<p align="justify"><a name="_Toc495916159"><i><font face="Times New Roman,sans-serif,Courier,mono" ,size="3">Линейный
  </font></i></a><i><font face="Times New Roman,sans-serif,Courier,mono",size="3">поиск</font></i></p>
<p align="justify">Совокупность записей о файлах
  в директории является линейным списком символьных имен файлов. Существует несколько
  стратегий просмотра  такого списка. Простейшей из них является линейный поиск.
  Директория просматривается с самого начала, пока не встретится нужное имя файла.
  Хотя это наименее эффективный способ поиска, оказывается, что в большинстве
  случаев он работает с приемлемой производительностью.  Например, авторы <font face="Times New Roman,sans-serif,Courier,mono",size="3">Unix</font>
  утверждали, что вполне достаточно линейного поиска. По-видимому,  это связано
  с  тем, что на фоне относительно медленного доступа к диску, некоторые задержки,
  возникающие в процессе сканирования списка несущественны. </p>
<p align="justify">Метод прост, но требует временных
  затрат.  Для создания нового файла вначале нужно просканировать директорию на
  наличие такого же имени. Затем,  имя нового файла вставляется в конец директории
  (если, разумеется, файл с таким же именем в директории не существует, в противном
  случае нужно информировать пользователя). Для удаления  файла нужно также выполнить
  поиск его имени в списке и пометить запись как неиспользуемую. </p>
<p align="justify">Реальный недостаток данного метода
  - линейный поиск файла. Информация  о структуре директории используется часто,
  и плохая реализация будет замечена пользователями. Можно свести поиск к бинарному,
  если отсортировать список файлов. Однако это усложнит создание и удаление файлов,
  так как требуется перемещения большого объема информации.  </p>
<p align="justify"><i>Хеш  таблица</i></p>
<p align="justify">Хеширование (см. например, [13]) - другой способ, который может 
  быть использован для размещения и последующего поиска имени файла в директории.  
  В данном методе имена файлов также хранятся в каталоге в виде линейного списка, 
  но дополнительно используются хеш таблица. Хеш таблица, точнее построенная на 
  ее основе хеш-функция позволяет по имени файла получить указатель на имя файла  
  в списке.  Таким образом,  можно существенно уменьшить время поиска. </p>
<p style='text-align:justify'>В результате хеширования могут возникать коллизии,
  то есть ситуации, когда  функция хеширования, примененная к разным именам файлов,
  дает один и тот же результат. Обычно имена таких файлов объединяют в связные
  списки,  предполагая в дальнейшем осуществление в них последовательного  поиска
  нужного имени файла. Выбор хорошего алгоритма хеширования позволяет свести к
  минимуму число коллизий.  Однако  всегда есть вероятность неблагоприятного исхода,
  когда непропорционально большому  числу имен файлов функция хеширования ставит
  в соответствие один и тот же результат. В этом случае преимущество использования
  этой схемы по сравнению с последовательным поиском практически утрачиваются.</p>
<p align="justify"><i><font face="Times New Roman,sans-serif,Courier,mono" ,size="3">Другие
  методы поиска</font></i></p>
<p style='text-align:justify'>Помимо описанных методов поиска имени файла в директории 
  существуют и другие. В качестве примера можно привести организацию поиска в 
  каталогах файловой системы <font face="Times New Roman,sans-serif,Courier,mono",size="3">NTFS</font> 
  при помощи, так называемого <font face="Times New Roman,sans-serif,Courier,mono",size="3">B</font>-дерева, 
  которое стало стандартным способом организации индексов в системах баз данных 
  (см., например, [13]).</p>
<p align="justify"><b><font face="Times New Roman,sans-serif,Courier,mono" ,size="3">
<a name="l1205">12.5  Монтирование файловых систем. </a></font></b></p>
<p align="justify">Как файл должен быть открыт перед
  использованием,  так и  файловая система, хранящаяся на разделе диска, должна
  быть смонтирована, чтобы стать доступной процессам системы.</p>
<p align="justify">Функция <font face="Times New Roman,sans-serif,Courier,mono",size="3">mount</font>
  (монтировать) связывает файловую систему из указанного раздела на диске с существующей
  иерархией файловых систем, а функция umount (демонтировать) выключает файловую
  систему из иерархии. Функция mount, таким образом, дает пользователям возможность
  обращаться к данным в дисковом разделе как к файловой системе, а не как к последовательности
  дисковых блоков.</p>
<p align="justify">Процедура монтирования состоит в следующем.  Пользователь (в 
  <font face="Times New Roman,sans-serif,Courier,mono",size="3">Unix</font> это 
  суперпользователь) сообщает ОС имя устройства и место в файловой структуре  
  (имя пустого каталога), куда  нужно присоединить файловую систему (точка монтирования).  
  Например, в ОС <font face="Times New Roman,sans-serif,Courier,mono",size="3">Unix</font><font face="Times New Roman,sans-serif,Courier,mono",size="3"> 
  </font>системный вызов mount имеет вид: </p>
<p style='text-align:justify'>   <font face="Times New Roman,sans-serif,Courier,mono",size="3">mount(special pathname,directory
  pathname,options);</font></p>
<p style='text-align:justify'>где special pathname - имя специального файла устройства
  (в общем случае имя раздела), соответствующего дисковому разделу с монтируемой
  файловой системой, directory pathname - каталог в существующей иерархии, где
  будет монтироваться файловая система (другими словами, точка или место монтирования),
  а options указывает, следует ли монтировать файловую систему &quot;только для
  чтения&quot; (при этом не будут выполняться такие функции, как write и creat,
  которые производят запись в файловую систему).  Затем ОС проверяет, что устройство
  содержит действительную файловую систему ожидаемого формата с суперблоком, списком
  индексов и корневым индексом.</p>
<p style='text-align:justify'>Некоторые ОС осуществляют монтирование автоматически,
  как только встретят диск в первый раз (жесткие диски на этапе загрузки, гибкие
  - когда они вставлены в дисковод), ОС ищет файловую систему на устройстве. Если
  файловая система на устройстве имеется, она монтируется на корневом уровне,
  при этом к цепочке имен  абсолютного имени файла (<font face="Times New Roman,sans-serif,Courier,mono",size="3">pathname</font>)
  добавляется буква раздела.</p>
<p style='text-align:justify'><img border="0" src="images/image009.gif" width="628" height="220"></p>
<p align="justify"><font size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  Рис. 12.9.  Две файловые системы до монтирования</font></p>
<p align="justify"><img border="0" src="images/image010.gif" width="333" height="247"></p>
<p align="justify"><font size="2">Рис. 12.10.  Общая файловая система после монтирования</font></p>
<p align="justify">Ядро поддерживает таблицу монтирования с записями о каждой 
  монтированной файловой системе. В каждой записи содержатся информация о вновь 
  смонтированном устройстве, в частности на буфер с его суперблоком и корневой 
  каталог, а также информация о точке монтирования. Для устранения потенциально 
  опасных побочных эффектов число ссылок (<a href="#l1206">см. 
  следующий раздел</a>) на каталог точку монтирования должно быть равно 1. Занесение 
  информации в таблицу монтирования производится немедленно, поскольку  монтирующий 
  процесс может приостановиться, следуя процедуре открытия устройства или считывая 
  суперблок файловой системы, а другой процесс тем временем попытался бы смонтировать 
  файловую систему.  </p>
<p align="justify">Наличие в логической структуре
  файлового архива точек монтирования требует аккуратной реализации алгоритмов,
  осуществляющих навигацию по каталогам. Точку монтирования можно пересечь двумя
  способами: из файловой системы, где производится монтирование, в файловую систему,
  которая монтируется (в направлении от глобального корня к листу), и в обратном
  направлении. Алгоритмы поиска файлов должны предусматривать ситуации, в которых
  очередной компонент пути к файлу является точкой монтирования,  когда вместо
  анализа индексного узла очередной директории  приходится осуществлять обработку
  суперблока монтированной системы.</p>
<p align="justify"><b>
<a name="l1206">12.6  Связывание файлов. </a></b></p>
<p style='text-align:justify'>Иерархическая организация, положенная в основу древовидной
  структуры файловой системы современных ОС, не предусматривает выражения отношений,
  в которых потомки связываются более чем с одним предком. Такая  негибкость частично
  устраняется возможностью  реализации связывания файлов или организации линков.</p>
<p style='text-align:justify'><b><font face="Times New Roman,sans-serif,Courier,mono" ,size="3">
<a name="l120601">12.6.1 Организация связи между каталогом и разделяемым файлом </a></font></b></p>
<p style='text-align:justify'><img border="0" src="images/image011.gif" width="330" height="239"></p>
<p align="justify"><font size="2">Рис. 12.11  Структура файловой
  системы с возможностью связывания файла с новым именем.</font></p>
<p align="justify">Ядро позволяет пользователю связывать
  каталоги, упрощая написание программ, требующих пересечения дерева файловой
  системы. Часто имеет смысл хранить под разными именами одну и ту же команду
  (выполняемый файл). Например, выполняемый файл традиционного текстового редактора
  ОС UNIX <tt><font face="Times New Roman,sans-serif,Courier,mono",size="3">vi</font></tt> обычно может
  вызываться под <font face="Times New Roman,sans-serif,Courier,mono",size="3">именами </font><tt><font face="Times New Roman,sans-serif,Courier,mono",size="3">ex</font></tt><font face="Times New Roman,sans-serif,Courier,mono",size="3">, </font><tt><font face="Times New Roman,sans-serif,Courier,mono",size="3">edit</font></tt><font face="Times New Roman,sans-serif,Courier,mono",size="3">, </font><tt><font face="Times New Roman,sans-serif,Courier,mono",size="3">vi</font></tt><font face="Times New Roman,sans-serif,Courier,mono",size="3">, </font><tt><font face="Times New Roman,sans-serif,Courier,mono",size="3">view </font></tt><font face="Times New Roman,sans-serif,Courier,mono",size="3">и </font><tt><font face="Times New Roman,sans-serif,Courier,mono",size="3">vedit</font></tt> файловой системы. Соединение между директорией
  и разделяемым  файлом называется  связью или ссылкой (link).  Дерево файловой
  системы превращается  в циклический граф.</p>
<p align="justify">Это удобно, но создает ряд дополнительных проблем. <a href="../11/prep/sem11-12.htm#s1108">
<img src="../images/computer.gif" width="48" height="48" align="right" alt="Материалы семинарских занятий"  border="0"></a></p>
<p align="justify">Простейший способ реализовать
  связывание файла - просто дублировать информацию о нем в обеих директориях.
  При этом, однако, может возникнуть  проблема совместимости, в случае, если владельцы
  этих директорий попытаются независимо друг от друга изменить содержимое файла.
  Например,  если запись в директории  о файле непосредственно содержит адреса
  дисковых блоков, как в ОС CP/M, копии  тех же дисковых адресов должны быть сделаны
  и в  другой директории, куда файл линкуется. Если один из пользователей делает
  добавление к файлу, новые блоки будут перечислены только у него в директории
  и не будут видны другому пользователю.</p>
<p align="justify">Проблема  такого рода может быть
  решена двумя способами.  Первый из них, так называемая <i>жесткая</i>  связь.
  Если  блоки данных файла перечислены не в директории, а в небольшой структуре
  данных (например, в индексном узле), связанной собственно с файлом, то второй
  пользователь может связаться  непосредственно с этой, уже существующей структурой.
</p>
<p style='text-align:justify'>Альтернативное  решение -  создание нового файла,
  который содержит путь к связываемому файлу. Такой подход называется <i>символической</i>
  линковкой. При этом  в соответствующем каталоге создается элемент, в котором
  имени связи сопоставляется некоторое имя файла (этот файл даже не обязан существовать
  к моменту создания символической связи). Для символической связи может создаваться
  отдельный  индексный узел и даже заводиться отдельный блок данных для хранения
  потенциально длинного имени файла. </p>
<p align="justify">Каждый из этих методов имеет свои
  минусы. В случае жесткой связи возникает необходимость поддержки счетчика ссылок
  на файл, для корректной реализации операции удаления файла.  Например, в  <font face="Times New Roman,sans-serif,Courier,mono",size="3">Unix</font>,
  такой счетчик является одним из атрибутов, хранимым в индексном узле.  Удаление
  файла одним из пользователей  уменьшает количество ссылок на файл на 1.  Реальное
  удаление файла происходит, когда  число ссылок на файл становится равным 0.</p>
<p align="justify">В случае символической  линковки
  такая проблема не возникает,  т.к. только реальный владелец имеет  ссылку  на
  индексный узел файла.  Если собственник удаляет файл, то он разрушается, и попытки
  других пользователей  работать с ним кончатся провалом. Удаление символического
  линка никак  не влияет на файл. Проблема  организации символической  связи 
  потенциальное снижение скорости доступа к файлу. Файл символического линка содержит
  путь к файлу, содержащий список вложенных директорий,  для прохождения по которому
  необходимо осуществить несколько обращений к диску.</p>
<p align="justify">Символический линк имеет то преимущество,
  что он может использоваться для униформного доступа к файлам  удаленных компьютеров,
  если, например,  добавить к пути сетевой адрес удаленной машины.</p>
<p align="justify">Циклический граф структура более
  гибкая, нежели простое дерево, но работа с ней требует большой аккуратности.
  Одна из серьезных проблем со структурой циклического графа - гарантия того,
  что не возникает циклов при поиске файла. Поскольку  теперь к файлу существует
  несколько путей, программа поиска файла может найти его на диске несколько раз.
  Простейшее практическое решение данной проблемы - ограничить число директорий
  при поиске. Полное устранение циклов довольно трудоемкая процедура, выполняемая
  специальными утилитами и связанная с многократной трассировкой  директорий файловой
  системы. </p>
<p align="justify"><b>
<a name="l1207">12.7  Кооперация процессов при работе с файлами. </a></b></p>
<p style='text-align:justify'>Когда различные  пользователи  работают вместе над
  проектом, они часто нуждаются  в разделении файлов. </p>
<p align="justify">Разделяемый файл является
разделяемым
  ресурсом.  Как и в случае любого совместно используемого ресурса,  процессы должны
  синхронизировать свой доступ к совместно используемым файлам, каталогам, чтобы
  избежать тупиковых ситуаций, дискриминации отдельных процессов и снижения производительности
  системы.  </p>
<p align="justify">Например, если несколько пользователей
  одновременно редактируют какой-либо файл и не принято специальных мер, то результат
  будет непредсказуем и зависит от того, в каком порядке осуществлялись записи
  в файл.  Между двумя операциями <font face="Times New Roman,sans-serif,Courier,mono",size="3">read</font> одного процесса,
  другой процесс может модифицировать данные, что неприемлемо для многих приложений.
  Простейшее решение данной проблемы  предоставить возможность одному из процессов
  захватить файл, то есть блокировать доступ к разделяемому файлу других процессов
  на все время, пока файл остается открытым для данного процесса. Однако это было
  бы не гибко и не соответствовало бы характеру поставленной задачи.</p>
<p align="justify">Основные способы средство   временный
  захват процессом файла или записи (части файла между указанными позициями),
  а также блокировки  отдельных структур ядра, отвечающих за работу с файлами.
  Так, в ОС <font face="Times New Roman,sans-serif,Courier,mono",size="3">Unix</font> во время системного вызова, осуществляющего ту или иную
  операцию с файлом, как правило,  происходит блокирование индексного узла, содержащего
  адреса блоков данных файла.  Может показаться, что организация блокировок или
  запрета более чем одному процессу работать с файлом  во время выполнения системного
  вызова является излишней, так как  в подавляющем большинстве случаев выполнение
  системных вызовов и так не прерывается, то есть ядро работает в условиях невытесняющей
  многозадачности.  Однако в данном случае это не совсем так. Операции чтения
  и записи занимают продолжительное время и лишь инициируются центральным процессором,
  а осуществляются по независимым каналам, поэтому установка блокировок  на время
  системного вызова является необходимой  гарантией атомарности операций чтения
  и записи. </p>
<p style='text-align:justify'>Системный вызов, позволяющий установить и проверить
  блокировки на файл,  является неотъемлемым атрибутом современных многопользовательских
  ОС.  В принципе, было бы логично связать синхронизацию доступа к файлу как к
  единому целому с системным вызовом <tt><font face="Times New Roman,sans-serif,Courier,mono",size="3">open</font></tt> (т.е., например, открытие файла в режиме записи
  или обновления могло бы означать его монопольную блокировку соответствующим
  процессом, а открытие в режиме чтения - совместную блокировку). Так поступают
  во многих операционных системах (начиная с ОС Multics). В ОС <font face="Times New Roman,sans-serif,Courier,mono",size="3">Unix</font>
  это не так, что имеет исторические причины.</p>
<p style='text-align:justify'>В первой версии системы U<font face="Times New Roman,sans-serif,Courier,mono",size="3">nix</font>, разработанной Томпсоном и Ричи, механизм  захвата файла
  отсутствовал. Применялся очень простой подход к обеспечению параллельного (от
  нескольких процессов) доступа к файлам: система позволяла любому числу процессов
  одновременно открывать один и тот же файл в любом режиме (чтения, записи или
  обновления) и не предпринимала никаких синхронизационных действий. Вся ответственность
  за корректность совместной обработки файла ложилась на использующие его процессы,
  и система даже не предоставляла каких-либо особых средств для синхронизации
  доступа процессов к файлу.  Однако впоследствии, для того, чтобы повысить привлекательность
  системы для коммерческих пользователей, работающих с базами данных, в версию
  V системы  были включены механизмы захвата файла и записи, базирующиеся на системном
  вызове <font face="Times New Roman,sans-serif,Courier,mono",size="3">fcntl</font>. </p>
<p style='text-align:justify'>Допускаются два варианта синхронизации: с ожиданием,
  когда требование блокировки может привести к откладыванию процесса до того момента,
  когда это требование может быть удовлетворено, и без ожидания, когда процесс
  немедленно оповещается об удовлетворении требования блокировки или о невозможности
  ее удовлетворения в данный момент времени. </p>
<p style='text-align:justify'>Установленные блокировки относятся только к тому
  процессу, который их установил, и не наследуются процессами-потомками этого
  процесса. Более того, даже если некоторый процесс пользуется синхронизационными
  возможностями системного вызова <tt><font face="Times New Roman,sans-serif,Courier,mono",size="3">fcntl</font></tt>, другие процессы по-прежнему могут работать с тем
  файлом без всякой синхронизации. Другими словами, это дело группы процессов,
  совместно использующих файл, - договориться о способе синхронизации параллельного
  доступа. </p>
<p style='text-align:justify'><b><font face="Times New Roman,sans-serif,Courier,mono" ,size="3">Примеры разрешения
  коллизий и тупиковых ситуаций</font></b></p>
<p style='text-align:justify'>Логика  работы системы  в сложных ситуациях может
  проиллюстрировать особенности организации мультидоступа. </p>
<p style='text-align:justify'>Рассмотрим в качестве примера <i>образование потенциального 
  тупика</i> при образовании связи (<font face="Times New Roman,sans-serif,Courier,mono",size="3">link) 
  при совместном доступе к файлу <a href="../literature/literature.htm">[1]</a>.</font></p>
<p style='text-align:justify'><font face="Times New Roman,sans-serif,Courier,mono" ,size="3">Два процесса, выполняющие
  одновременно следующие функции: </font></p>
<pre style='text-align:justify'><font face="Times New Roman,sans-serif,Courier,mono" ,size="3">&nbsp;&nbsp; </font><font face="Times New Roman,sans-serif,Courier,mono" ,size="3">процесс</font> A:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; link(&quot;a/b/c/d&quot;,&quot;e/f/g&quot;);</pre>
<pre
style='text-align:justify'><font face="Times New Roman,sans-serif,Courier,mono" ,size="3">&nbsp;&nbsp;&nbsp; </font><font face="Times New Roman,sans-serif,Courier,mono" ,size="3">процесс</font> B:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; link(&quot;e/f&quot;,&quot;a/b/c/d/ee&quot;);</pre>
<p style='text-align:justify'><font face="Times New Roman,sans-serif,Courier,mono" ,size="3">могут 
  зайти в тупик. </font><font face="Times New Roman,sans-serif,Courier,mono" ,size="3">Предположим, 
  что процесс A обнаружил индекс файла &quot;a/b/c/d&quot; в тот самый момент, 
  когда процесс B обнаружил индекс файла &quot;e/f&quot;. Фраза &quot;в тот же 
  самый момент&quot; означает, что система достигла состояния, при котором каждый 
  процесс получил искомый индекс. Когда же теперь процесс A попытается получить 
  индекс файла &quot;e/f&quot;, он приостановит свое выполнение до тех пор, пока 
  индекс файла &quot;f&quot; не освободится. В то же время процесс B пытается 
  получить индекс каталога &quot;a/b/c/d&quot; и приостанавливается в ожидании 
  освобождения индекса файла &quot;d&quot;. Процесс A будет удерживать заблокированным 
  индекс, нужный процессу B, а процесс B, в свою очередь, будет удерживать заблокированным 
  индекс, нужный процессу A.</font></p>
<p style='text-align:justify'>Для предотвращения этого классического примера взаимной
  блокировки  в файловой системе принято, чтобы ядро освобождало индекс исходного
  файла после увеличения значения счетчика связей. Тогда, поскольку первый из
  ресурсов (индекс) свободен при обращении к следующему ресурсу, взаимная блокировка
  не происходит. </p>
<p style='text-align:justify'>Поводов для нежелательной <i>конкуренции</i><b>
  </b>между процессами много, особенно <i>при удалении</i> имен каталогов. Предположим,
  что один процесс пытается найти данные файла по его полному символическому имени,
  последовательно проходя компонент  за компонентом, а другой процесс удаляет
  каталог, имя которого входит в путь поиска. Допустим, процесс A делает разбор
  имени &quot;a/ b/c/d&quot; и приостанавливается во время получения индексного
  узла для файла &quot;c&quot;. Он может приостановиться при попытке заблокировать
  индексный узел или при попытке обратиться к дисковому блоку, где этот индексный
  узел хранится. Если процессу B нужно удалить связь для каталога с именем &quot;c&quot;,
  он может приостановиться по той же самой причине, что и процесс A. Пусть ядро
  впоследствии решит возобновить процесс B раньше процесса A. Прежде чем процесс
  A продолжит свое выполнение, процесс B завершится, удалив связь каталога &quot;c&quot;
  и его содержимое по этой связи. Позднее, процесс A попытается обратиться к несуществующему
  индексному узлу, который уже был удален. Алгоритм  поиска файла, проверяющий
  в первую очередь неравенство значения счетчика связей нулю, должен сообщить
  об ошибке. </p>
<p style='text-align:justify'>Можно привести и другие примеры, которые демонстрируют
  необходимость аккуратного дизайна файловой системы  для ее последующей надежной
  работы.</p>
<p style='text-align:justify'><a name="_Toc496007892"><b> <a name="l1208">12.8  
  Надежность файловой системы.</a></b></a><b><font face="Times New Roman,sans-serif,Courier,mono",size="3"> 
  </font></b></p>
<p align="justify"><font face="Times New Roman,sans-serif,Courier,mono" ,size="3">Жизнь
  полна неприятных неожиданностей, а разрушение файловой системы зачастую более
  опасно, чем разрушение компьютера. Поэтому необходимо предпринимать специальные
  меры для сохранения структуры файловой системы на диске. Помимо очевидных решений,
  например, своевременное дублирование информации (</font><font face="Times New Roman,sans-serif,Courier,mono",size="3">backup</font>), файловые системы
  современных ОС содержат  специальные средства для поддержки собственной совместимости.</p>
<p style='text-align:justify'><b><font face="Times New Roman,sans-serif,Courier,mono",size="3">
<a name="l120801">12.8.1 Целостность файловой системы. </a></font></b></p>
<p style='text-align:justify'>Важный аспект надежной работы файловой системы 
  контроль ее целостности. В результате файловых операций блоки диска могут считываться
  в память, модифицироваться  и затем записываться на диск. Причем, многие файловые
  операции затрагивают сразу несколько объектов файловой системы. И, если, вследствие
  непредсказуемого останова системы, на диске будут сохранены изменения только
  для части этих объектов (нарушена атомарность  файловой операции), файловая
  система на диске может быть оставлена в несовместимом состоянии. В результате
  могут возникнуть нарушения логики работы с данными, например,  появиться потерянные
  блоки диска, которые не принадлежат ни одному файлу и, в то же время помечены
  как занятые или наоборот блоки, помеченные, как свободные, но в то же время
  занятые (на них есть ссылка в индексном узле)  или другие нарушения.</p>
<p style='text-align:justify'>В современных ОС предусмотрены меры, которые позволяют
  свести к минимуму ущерб от порчи файловой системы и, затем, восстановить ее
  целостность.</p>
<p align="justify">Очевидно, что для правильного
  функционирования файловой системы,  значимость отдельных данных неравноценна.
  Искажение содержимого пользовательских файлов не приводит к серьезным (с точки
  зрения целостности файловой системы) последствиям, тогда как несоответствия
  в файлах, содержащих управляющую информацию (директории, индексные узлы, суперблок
  и т.п.), могут  быть катастрофическими. Поэтому должен быть тщательно продуман
  порядок совершения операций  со структурами данных файловой системы.</p>
<p align="justify">Рассмотрим, пример создания жесткой связи для файла <a href="../literature/literature.htm">[32]</a>. 
  Для этого файловой системе необходимо выполнить следующие операции:</p>
<p align="justify"> 1.<font face="Times New Roman,sans-serif,Courier,mono",size="3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  </font> Создать новую запись в каталоге, указывающую на индексный узел файла</p>
<p align="justify"> 2.<font face="Times New Roman,sans-serif,Courier,mono",size="3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  </font> Увеличить счетчик связей в индексном узле</p>
<p align="justify">Если аварийный останов произошел
  между 1-й и 2-й операциями, то в каталогах файловой системе будут существовать
  два имени файла, адресующих индексный узел со значением счетчика связей, равному
  1. если теперь будет удалено одно из имен, это приведет к удалению файла как
  такового. Если же порядок операций изменен и, как прежде, останов произошел
  между первой и второй операциями, файл будет иметь несуществующую жесткую связь,
  но существующая запись в каталоге будет правильной. Хотя это тоже является ошибкой,
  но ее последствия менее серьезны, чем в предыдущем случае.</p>
<p align="justify">Другим средством поддержки целостности
  является способ реализации файловой операции в виде транзакции, примерно как,
  как это делается в СУБД.  Последовательность действий с объектами во время файловой
  операции протоколируется,  и, если произошел останов системы, то, имея в наличии
  протокол, можно осуществить откат системы назад в исходное целостное состояние,
  в котором она пребывала до начала операции. Такого рода журналирование реализовано
  в <font face="Times New Roman,sans-serif,Courier,mono",size="3">NTFS</font>.</p>
<p align="justify">Если же нарушение все же произошло,
  то для устранения проблемы несовместимости можно прибегнуть к <i>утилитам</i><b>
  </b>(<font face="Times New Roman,sans-serif,Courier,mono",size="3">fsck</font>, <font face="Times New Roman,sans-serif,Courier,mono",size="3">chkdsk</font>, <font face="Times New Roman,sans-serif,Courier,mono",size="3">scandisk</font> и др.), которые  проверяют целостность файловой системы.
  Они могут запускаться после загрузки или после сбоя и осуществляют многократное
  сканирование разнообразных  структур данных файловой системы в поисках противоречий.
</p>
<p align="justify">Возможны также  эвристические проверки. Например, нахождение 
  индексного узла, номер, которого превышает их число на диске или  нахождение 
  в пользовательских директориях файлов принадлежащих суперпользователю. </p>
<p style='text-align:justify'><b><font face="Times New Roman,sans-serif,Courier,mono",size="3"> </font></b></p>
<p style='text-align:justify'><b><font face="Times New Roman,sans-serif,Courier,mono",size="3">
<a name="l120802">12.8.2 Управление плохими блоками. </a></font></b><b><font face="Times New Roman,sans-serif,Courier,mono",size="3"> </font></b></p>
<p align="justify">Наличие плохих блоков на диске
  обычное  дело. Под плохими блоками обычно понимают блоки диска, для которых
  вычисленная контрольная сумма  считываемых данных не совпадает с хранимой  контрольной
  суммой.  Часто появляются в процессе эксплуатации. Иногда они уже имеются при
  поставке вместе со списком, т.к. очень затруднительно для поставщиков сделать
  диск полностью свободным от дефектов.  Два решения проблемы плохих блоков -
  одно на уровне аппаратуры другое на уровне ядра ОС.</p>
<p align="justify">Первый способ -  хранить список
  плохих  блоков в контроллере диска. Когда контроллер инициализируется, он читает
  плохие блоки и замещает дефектный  блок  резервным, помечая отображение в списке
  плохих блоков. Все реальные запросы будут идти к  резервному блоку.  Следует
  иметь в виду, что при этом механизм подъемника (наиболее распространенный механизм
  обработки запросов к блокам диска) будет работать неэффективно. Дело в том,
  что  существует стратегия очередности обработки запросов к диску (подробнее
  см. главу ввод-вывод).  Стратегия диктует направление движения считывающей
  головки диска к  нужному цилиндру.  Обычно резервные блоки размещаются на внешних
  цилиндрах.  Если плохой блок расположен на внутреннем цилиндре,  и контроллер
  осуществляет  подстановку прозрачным образом, то кажущееся движение головки
  будет осуществляться  к внутреннему цилиндру, а фактическое к внешнему.  Это
  является нарушением стратегии и, следовательно, минусом данной схемы.</p>
<p align="justify">Решение на уровне ОС может быть
  следующим. Во-первых, необходимо  тщательно сконструировать файл, содержащий
  плохие блоки. Тогда они изымаются из списка свободных блоков.  Затем нужно сделать
  так, чтобы к этому файлу не было обращений. Если это возможно, то  проблема
  решена.</p>
<p align="justify"> </p>
<p style='text-align:justify'><b>
<a name="l1209">12.9  Производительность файловой системы </a></b></p>
<p align="justify">Наиболее типичная техника повышения
  скорости работы с диском  <i>кэширование</i>. Обращение к диску обычно в 100000
  раз медленнее, чем к памяти. (Обращение к памяти - несколько сотен наносекунд,
  а чтение блока с диска - десятки миллисекунд).  За счет кэширования дисковой
  информации в памяти можно сократить число дисковых операций,  храня часть блоков
  диска, к которым перед этим производились обращения, в специальной области памяти,
  именуемой буферным кэшем (cache). Это оказывается возможным вследствие присущего ОС
  свойству локальности (о свойстве локальности много говорилось в главах, посвященных
  описанию работы системы управления памятью). </p>
<p align="justify">Различные  алгоритмы используются
  для управления кэшем, но наиболее общий - при запросах на чтение проверять находится
  ли соответствующий  блок в буфер кэша, и если нет, то вначале считать его в
  буфер.</p>
<p align="justify">Аккуратная реализация кэширования
  требует решения нескольких проблем.</p>
<p align="justify">Во-первых, емкость буфера кэша
  ограничена. Когда блок должен быть загружен в  заполненный буфер кэша, возникает
  <i>проблема замещения</i><b> </b>блоков, то есть отдельные блоки должны быть
  удалены из него. Эта ситуация очень напоминает  ситуацию с выталкиванием страниц
  памяти, и  здесь используются те же алгоритмы, например,  FIFO, Second Chance
  и LRU. Разница лишь в том, что ссылки кэша не столь часты, как ссылки на страницы
  памяти.</p>
<p align="justify">Замещение блоков должно осуществляться
  с учетом их важности для файловой системы. Блоки должны быть разделены <i>на
  категории,</i> например: блоки индексных узлов, блоки косвенной адресации, блоки
  директорий, заполненные блоки данных и т.д., и в зависимости от принадлежности
  блока к той или иной категории применять к ним разную стратегию замещения.</p>
<p align="justify">Во-вторых, поскольку кэширование
  использует механизм отложенной записи, при котором модификация буфера не вызывает
  немедленной записи на диск, серьезной проблемой является старение информации
  в дисковых блоках, образы которых находятся в буферном кэше. Несвоевременная
  <i>синхронизация</i> буфера кэша и диска может привести к очень нежелательным
  ситуациям в случае отказов оборудования или программного обеспечения. Поэтому
  стратегия и порядок отображения информации из кэша на диск должна быть тщательно
  продумана.</p>
<p align="justify">Так, блоки существенные  для совместимости файловой  системы 
  (блоки индексных узлов, блоки косвенной адресации, блоки директорий), должны 
  быть переписаны на диск немедленно, независимо от того в какой части <font face="Times New Roman,sans-serif,Courier,mono",size="3">LRU</font> 
  цепочки они находятся. Необходимо тщательно  выбрать порядок такого переписывания. 
</p>
<p align="justify">В UNIX имеется для этого вызов
  SYNC, который  заставляет  все модифицированные  блоки записываться на диск
  немедленно. Для периодической  синхронизации содержимого кэша и диска запускается
  фоновый процесс-демон, который   делает это через  определенный промежуток времени
  (например, каждые 30 сек.). Кроме того, можно организовать синхронный режим
  работы с отдельными файлами, задаваемый при открытии файла, когда все изменения
  в файле немедленно сохраняются на диске.</p>
<p align="justify">В ОС  MS-DOS, в отличие от <font face="Times New Roman,sans-serif,Courier,mono",size="3">Unix</font>,
  принято записывать каждый  модифицированный  блок на диск как можно скорее.
  Следствие такой стратегии - удаление  дискеты из UNIX системы без осуществления
  вызова SYNC почти всегда ведет к потере данных, тогда как у MS-DOS здесь проблем
  не возникает (в UNIX предполагается, что все диски жесткие и не вынимаются)</p>
<p align="justify">Кэширование <i>- не единственный</i>
  способ увеличения производительности системы.  Другая важная техника - сокращение
  количества движений  считывающей головки диска, за счет разумной стратегии размещения
  информации. Например, массив индексных узлов в <font face="Times New Roman,sans-serif,Courier,mono",size="3">Unix</font> стараются разместить
  на средних  дорожках.  Также имеет смысл размещать  индексные узлы  поблизости
  от блоков данных, на которые  они ссылаются и т.д.</p>
<p align="justify"><b><font face="Times New Roman,sans-serif,Courier,mono",size="3">
<a name="l1210">12.10 Реализация некоторых операций над файлами.</a></font></b></p>
<p align="justify">В предыдущей главе перечислены основные операции над файлами.  
  В данном разделе будет описан порядок работы <a href="../11/prep/sem11-12.htm#s1107"> 
  <img src="../images/computer.gif" width="48" height="48" align="right"  alt="Материалы семинарских занятий" border="0"></a> 
  некоторых  системных вызовов для работы с файловой системой, следуя главным 
  образом <a href="../literature/literature.htm">[1]</a>, с учетом совокупности 
  введенных в данной главе понятий. </p>
<p style='text-align:justify'><b>
<a name="l121001">12.10.1 Системные вызовы, работающие с символическим именем файла.</a></b></p>
<p style='text-align:justify'><i><font face="Times New Roman,sans-serif,Courier,mono",size="3">Системные вызовы,
  связывающие </font></i><i><font face="Times New Roman,sans-serif,Courier,mono",size="3">pathname</font></i><i><font face="Times New Roman,sans-serif,Courier,mono",size="3"> с дескриптором файла</font></i></p>
<p style='text-align:justify'>Это функции создания и открытия файла. Например,
  в ОС <font face="Times New Roman,sans-serif,Courier,mono",size="3">Unix</font></p>
<p style='text-align:justify'><font face="Times New Roman,sans-serif,Courier,mono",size="3">fd = creat(pathname,modes);</font></p>
<p style='text-align:justify'><font face="Times New Roman,sans-serif,Courier,mono",size="3">fd 
  = open(pathname,flags,modes);<a href="../11/prep/sem11-12.htm#s1108">
<img src="../images/computer.gif" width="48" height="48" align="right" alt="Материалы семинарских занятий"  border="0"></a></font></p>
<p style='text-align:justify'>Другие операции над файлами, такие как чтение, запись,
  позиционирование головок чтения-записи, воспроизведение дескриптора файла, установка
  параметров ввода-вывода, определение статуса файла и закрытие файла, используют
  значение полученного дескриптора файла.</p>
<p style='text-align:justify'>Рассмотрим работу системного вызова <font face="Times New Roman,sans-serif,Courier,mono",size="3">open</font>.</p>
<p style='text-align:justify'>Логическая файловая подсистема просматривает файловую
  систему в поисках файла по его имени. Она проверяет права на открытие файла
  и выделяет открываемому файлу запись в таблице файлов. Запись таблицы файлов
  содержит указатель на индексный узел открытого файла. Ядро выделяет запись в
  личной (закрытой) таблице в адресном пространстве процесса, выделенном процессу
  (таблица эта называется таблицей пользовательских дескрипторов файлов), и запоминает
  указатель на эту запись. Указателем выступает дескриптор файла, возвращаемый
  пользователю. Запись в таблице пользовательских файлов указывает на запись в
  глобальной таблице файлов.</p>
<p align="justify"><img border="0" src="images/image012.gif" width="635" height="440"></p>
<p align="justify"><font size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Рис. 12.12   Структуры
  данных после открытия файлов</font></p>
<p align="justify">Первые три пользовательских дескриптора
  (0, 1 и 2) именуются дескрипторами файлов: стандартного ввода, стандартного
  вывода и стандартного файла ошибок. Процессы в системе UNIX по договоренности
  используют дескриптор файла стандартного ввода при чтении вводимой информации,
  дескриптор файла стандартного вывода при записи выводимой информации и дескриптор
  стандартного файла ошибок для записи сообщений об ошибках.</p>
<p style='text-align:justify'><i>Связывание  файла </i></p>
<p style='text-align:justify'>Системная функция link связывает файл с новым именем
  в структуре каталогов файловой системы, создавая для существующего индекса новую
  запись в каталоге. Синтаксис вызова функции link: </p>
<p style='text-align:justify'><font face="Times New Roman,sans-serif,Courier,mono",size="3">   </font><font face="Times New Roman,sans-serif,Courier,mono",size="3">link(source file name, target file name);</font></p>
<p style='text-align:justify'>где source file name - существующее имя файла, а
  target file name - новое (дополнительное) имя, присваиваемое файлу после выполнения
  функции link. </p>
<p style='text-align:justify'>Сначала ОС, определяет местонахождение индекса исходного
  файла и увеличивает значение счетчика связей в индексном узле. Затем ядро ищет
  файл с новым именем; если он существует, функция link завершается неудачно и
  ядро восстанавливает прежнее значение счетчика связей, измененное ранее. В противном
  случае ядро находит в родительском каталоге свободную запись для файла с новым
  именем, записывает в нее новое имя и номер индекса исходного файла. </p>
<p style='text-align:justify'><i><font face="Times New Roman,sans-serif,Courier,mono",size="3"> </font>Удаление файла</i></p>
<p style='text-align:justify'>В Unix системная функция unlink удаляет из каталога
  точку входа для файла. Синтаксис вызова функции unlink: </p>
<p style='text-align:justify'><font face="Times New Roman,sans-serif,Courier,mono",size="3">   </font>unlink(pathname);</p>
<p style='text-align:justify'>Если удаляемое имя является последней связью файла
  с каким-либо каталогом, ядро в итоге освобождает все информационные блоки файла.
  Однако если у файла было несколько связей, он остается все еще доступным под
  другими именами.</p>
<p style='text-align:justify'>Для того чтобы забрать дисковые блоки, ядро в цикле
  просматривает таблицу содержимого индексного узла, освобождая все блоки прямой
  адресации немедленно. Что касается блоков косвенной адресации, ядро освобождает
  все блоки, появляющиеся на различных уровнях косвенности, рекурсивно, причем
  в первую очередь освобождаются блоки с меньшим уровнем. </p>
<p style='text-align:justify'><b><font face="Times New Roman,sans-serif,Courier,mono",size="3">
<a name="l121002">12.10.2 Системные вызовы, работающие с файловым дескриптором </a></font></b></p>
<p style='text-align:justify'><font face="Times New Roman,sans-serif,Courier,mono",size="3"> </font></p>
<p style='text-align:justify'><font face="Times New Roman,sans-serif,Courier,mono",size="3">Открытый 
  файл может использоваться для чтения и записи последовательностей байтов. Для 
  этого поддерживаются два системных вызова read и write, работающие с файловым 
  дескриптором (или handle'ом в терминологии Microsoft), полученном при ранее 
  выполненных системных вызовах </font><tt><font face="Times New Roman,sans-serif,Courier,mono",size="3">open</font></tt><font face="Times New Roman,sans-serif,Courier,mono",size="3"> 
  или </font><tt><font face="Times New Roman,sans-serif,Courier,mono",size="3">creat</font></tt><font face="Times New Roman,sans-serif,Courier,mono",size="3">. 
  </font></p>
<p style='text-align:justify'><i><font face="Times New Roman,sans-serif,Courier,mono",size="3"> </font>Функции ввода-вывода из файла</i></p>
<p style='text-align:justify'>Системный вызов <font face="Times New Roman,sans-serif,Courier,mono",size="3">read</font> выполняет
  чтение обычного файла</p>
<p style='text-align:justify'><font face="Times New Roman,sans-serif,Courier,mono",size="3">number = read(fd,buffer,count);</font></p>
<p style='text-align:justify'>где fd - дескриптор файла, возвращаемый функцией
  open, buffer - адрес структуры данных в пользовательском процессе, где будут
  размещаться считанные данные в случае успешного завершения выполнения функции
  read, count - количество байт, которые пользователю нужно прочитать, number
  - количество фактически прочитанных байт. </p>
<p style='text-align:justify'>Синтаксис вызова системной функции write (писать):
</p>
<p style='text-align:justify'><font face="Times New Roman,sans-serif,Courier,mono",size="3">   </font><font face="Times New Roman,sans-serif,Courier,mono",size="3">number = write(fd,buffer,count);</font></p>
<p style='text-align:justify'>где переменные fd, buffer, count и number имеют
  тот же смысл, что и для вызова системной функции read. Алгоритм записи в обычный
  файл похож на алгоритм чтения из обычного файла. Однако если в файле отсутствует
  блок, соответствующий смещению в байтах до места, куда должна производиться
  запись, ядро выделяет блок, и присваивает ему номер в соответствии с точным
  указанием места в таблице содержимого индексного узла. </p>
<p style='text-align:justify'>Обычное использование системных функций read и write
  обеспечивает последовательный доступ к файлу, однако процессы могут использовать
  вызов системной функции lseek для указания места в файле, где будет производиться
  ввод-вывод, и осуществления произвольного доступа к файлу. Синтаксис вызова
  системной функции: </p>
<p style='text-align:justify'><font face="Times New Roman,sans-serif,Courier,mono",size="3">   </font><font face="Times New Roman,sans-serif,Courier,mono",size="3">position = lseek(fd,offset,reference);</font></p>
<p style='text-align:justify'>где fd - дескриптор файла, идентифицирующий файл,
  offset - смещение в байтах, а reference указывает, является ли значение offset
  смещением от начала файла, смещением от текущей позиции ввода-вывода или смещением
  от конца файла. Возвращаемое значение, position, является смещением в байтах
  до места, где будет начинаться следующая операция чтения или записи.  </p>
<p style='text-align:justify'><b><font face="Times New Roman,sans-serif,Courier,mono",size="3">
<a name="l1211">12.11 Современные архитектуры файловых систем </a></font></b><b><font face="Times New Roman,sans-serif,Courier,mono",size="3"></font></b></p>
<p align="justify"><font face="Times New Roman,sans-serif,Courier,mono",size="3">Современные
  ОС предоставляют пользователю возможность работать сразу с несколькими файловыми
  системами (</font><font face="Times New Roman,sans-serif,Courier,mono",size="3">Linux</font><font face="Times New Roman,sans-serif,Courier,mono",size="3"> работает с </font><font face="Times New Roman,sans-serif,Courier,mono",size="3">Ext</font><font face="Times New Roman,sans-serif,Courier,mono",size="3">2</font><font face="Times New Roman,sans-serif,Courier,mono",size="3">fs</font><font face="Times New Roman,sans-serif,Courier,mono",size="3">, </font><font face="Times New Roman,sans-serif,Courier,mono",size="3">FAT</font> и др.).  Файловая система в традиционном
  понимании становится частью более общей многоуровневой структуры (см. рис. 12.12).</p>
<p align="justify">На верхнем уровне, на котором располагается
  так называемый  диспетчер файловых систем (например, в <font face="Times New Roman,sans-serif,Courier,mono",size="3">Windows</font> 95 этот компонент называется
  installable filesystem manager). Он связывает запросы прикладной программы
  с конкретной файловой системой. </p>
<p align="justify"><img border="0" src="images/image013.gif" width="579" height="470"> </p>
<p align="justify"><font size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Рис. 12.13  Архитектура современной
  файловой системы</font> </p>
<p align="justify">Каждая файловая система (иногда говорят
  драйвер файловой системы)  на этапе инициализации  регистрируется  у диспетчера,
  сообщая ему точки входа,  для последующих обращений к данной файловой системе.
</p>
<p align="justify">Та же идея поддержки нескольких файловых систем  в рамках одной 
  ОС может быть реализована по-другому, например, исходя из концепции виртуальной 
  файловой системы. Виртуальная файловая система (<font face="Times New Roman,sans-serif,Courier,mono",size="3">vfs</font>) 
  представляет собой независимый от реализации уровень и опирается на реальные 
  файловые системы (<font face="Times New Roman,sans-serif,Courier,mono",size="3">s</font>5<font face="Times New Roman,sans-serif,Courier,mono",size="3">fs</font>, 
  <font face="Times New Roman,sans-serif,Courier,mono",size="3">ufs</font>, <font face="Times New Roman,sans-serif,Courier,mono",size="3">FAT</font>, 
  <font face="Times New Roman,sans-serif,Courier,mono",size="3">NFS</font>, <font face="Times New Roman,sans-serif,Courier,mono",size="3">FFS</font>,<font face="Times New Roman,sans-serif,Courier,mono",size="3"> 
  Ext</font>2<font face="Times New Roman,sans-serif,Courier,mono",size="3">fs</font>). 
  При этом возникают структуры данных виртуальной файловой системы, типа виртуальных 
  индексных узлов <font face="Times New Roman,sans-serif,Courier,mono",size="3">vnode</font>, 
  которые обобщают индексные узлы конкретных систем .</p>
<p align="justify"><b><font face="Times New Roman,sans-serif,Courier,mono",size="3">
<a name="l1212">12.12 Резюме </a></font></b></p>
<p align="justify">Реализация файловой системы связана
  с такими вопросами, как поддержка понятия логического блока диска, связывания
  имени файла и блоков его данных, проблемами разделения файлов и проблемами управления
  дискового пространства. </p>
<p align="justify">Наиболее распространенные способы
  выделения дискового пространства: непрерывное выделение, организация связного
  списка и система с индексными узлами.</p>
<p align="justify">Файловая система часто реализуется
  в виде слоеной модульной структуры. Нижние слои имеют дело с оборудованием,
  а верхние с символическими именами и логическими свойствами файлов. </p>
<p align="justify">Директории могут быть организованы
  различными способами и могут хранить атрибуты файла и адреса блоков файлов,
  а иногда для этого предназначается специальная структура (индексные узлы). Проблемы
  надежности и производительности файловой системы  важнейшие аспекты ее дизайна.</p>
<p align="justify">&nbsp;</p>

<p align="center"><a href="../11/ch11.htm"> Предыдущая глава</a> | 
<a href="../os.html">Программа курса</a> | 
<a href="../13/ch13.htm"> Следующая глава</a></p>

</body>
</html>
