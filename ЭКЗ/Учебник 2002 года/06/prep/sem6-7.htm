<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
<TITLE>Семинары 6-7</TITLE>
</HEAD>
  <BODY bgcolor="#FFFFFF">
 <basefont face="Times New Roman" size="3">
 
<P ALIGN="CENTER"><B><FONT FACE="Times New Roman" SIZE = 6>Семинары 6-7. Средства System V IPC. Организация 
  работы с разделяемой памятью в UNIX. Понятие нитей исполнения (thread'ов).</FONT></B></P>
<P ALIGN="CENTER">(Основывается на <a href="../../04/l4.htm">лекции 4</a> и <a href="../../05/l5.htm">лекции 5</a>) </P>
<P align="center"><a href="../../05/prep/sem5.htm"> Предыдущий семинар</a> | <a href="../../os.html">Программа курса</a> | 
 <a href="../../08/prep/sem8.htm"> Следующий семинар</a></P>
<P ALIGN="CENTER"><B><font face="Times New Roman, Times, serif" size="4">Программа 
  семинара</font></B></P>
  <ol>
  <li><a href="#s0601"><font face="Times New Roman, Times, serif" size="3">Преимущества
    и недостатки потокового обмена данными.</font></a></li>
  <li><a href="#s0602"><font face="Times New Roman, Times, serif" size="3">Понятие 
    о System V IPC</font></a><font face="Times New Roman, Times, serif" size="3">.</font></li>
  <li><a href="#s0603"><font face="Times New Roman, Times, serif" size="3">Пространство
    имен. Адресация в System V IPC. Функция ftok().</font></a></li>
	 <li><a href="#s0604"><font face="Times New Roman, Times, serif" size="3">Дескрипторы System V IPC. </font></a></li>
  <li><a href="#s0605"><font face="Times New Roman, Times, serif" size="3">Разделяемая 
    память в UNIX. Системные вызовы shmget(), shmat(), shmdt().</font></a></li>
 <li><a href="#s0607"><font face="Times New Roman" size=3>Команды ipc и ipcrm.</font></a></li> 
  <li><a href="#s0608"><font face="Times New Roman, Times, serif" size="3">Использование 
    системного вызова shmctl() для освобождения ресурса.</font></a></li>
 <li><font face="Times New Roman, Times, serif" size="3"><a href="#s0609">Разделяемая
    память и системные вызовы fork(), exec() и функция exit().</a></font></li>
   <li><a href="#s0611"><font face="Times New Roman" size=3>Понятие о нити исполнения  (thread) в UNIX.
   Идентификатор нити исполнения. Функция pthread_self().</font></a></li>
  <li><font face="Times New Roman" size=3><a href="#s0612">Создание и завершение  thread'а. Функции pthread_create(), pthread_exit(),
 pthread_join().</a></font></li>
 <li><a href="#s0615"><font face="Times New Roman" size=3>Необходимость синхронизации процессов и нитей исполнения,
  использующих общую память.</font></a></li>
  </ol>
 <p align="center">
<font face="Times New Roman, Times, serif" size="3"><B><font size="4">Цели занятия</font></B></font> 
<OL>
  <li><P ALIGN="JUSTIFY"><font face="Times New Roman" size="3">Дать общее представление о System 
    Y IPC.</font></li>
  <li>
    <P ALIGN="JUSTIFY"><font face="Times New Roman" size="3">Привить навыки работы 
      с разделяемой памятью.</font>
  </li>
  <li><P ALIGN="JUSTIFY"> <font face="Times New Roman" size=3>Дать опыт работы с командами ipcs и 
    ipcrm.</font></li>
  <li><P ALIGN="JUSTIFY"> <font face="Times New Roman" size="3">Научить создавать и завершать threads 
    в рамках одного процесса.</font></li>
  <LI>
    <P ALIGN="JUSTIFY"><font face="Times New Roman" size=3>Студент должен осознать 
      разницу между созданием нового процесса и созданием нового thread’а.</font>
  </LI>
  <LI><P ALIGN="JUSTIFY"><font face="Times New Roman" size=3>Студент должен понять необходимость 
    синхронизации процессов и нитей исполнения при использовании разделяемой памяти.</font></LI>

</OL>
<P ALIGN="CENTER"><font face="Times New Roman, Times, serif" size="3"><B><font size="4">Практические 
  работы</font></B></font></P>
  <OL>
  <li><P ALIGN="JUSTIFY"><font face="Times New Roman, Times, serif" size="3"><a href="#s0606">
  Прогон программ с использованием разделяемой памяти</a>
  </font></li>
  <li><P ALIGN="JUSTIFY"><a href="#s0607"><font face="Times New Roman, Times, serif" size="3">Работа с командами ipcs и ipcrm.</font></a></li>
  <li><P ALIGN="JUSTIFY"><font face="Times New Roman, Times, serif" size="3"><a href="#s0610">
  Самостоятельное 
      написание, компиляция и запуск программы для организации связи двух процессов 
      через разделяемую память.</a>
  </font></li>
  <li><P ALIGN="JUSTIFY"><font face="Times New Roman, Times, serif" size="3"><a href="#s0613">Прогон программы 
    с использованием двух нитей исполнения.</a>
  </font></li>
   <li><P ALIGN="JUSTIFY"><font face="Times New Roman, Times, serif" size="3"><a href="#s0614">Написание, компиляция и прогон программы 
    с использованием трех нитей исполнения.</a>
  </font></li>
  <li><P ALIGN="JUSTIFY"><font face="Times New Roman, Times, serif" size="3"><a href="#s0615">Прогон программ, иллюстрирующих 
  необходимость синхронизации процессов и нитей исполнения,
  использующих общую память.</a>
  </font></li>

  </OL>

<P ALIGN="CENTER">&nbsp;</P>
<P ALIGN="CENTER"><B><font face="Times New Roman, Times, serif" size="4">План
занятия</font></B></P>
<ol>
  <LI> 
    <p align="JUSTIFY"><font  face="Times New Roman, Times, serif" size="3" color="#FF0000"><b><a name="s0601"></a>Преимущества 
      и недостатки потокового обмена данными.</b></font> <br>
      <br>
    <font face="Times New Roman, Times, serif" size="3"> 
    <p align="JUSTIFY">На <a href="../../05/prep/sem5.htm">предыдущем семинаре 
      </a>мы познакомились с механизмами, обеспечивающими потоковую передачу данных 
      между процессами в операционной системе UNIX, а именно с <a href="../../05/prep/sem5.htm#s0508">pip'ами</a> 
      и <a href="../../05/prep/sem5.htm#s0514">FIFO</a>. Потоковые механизмы достаточно 
      просты в реализации и удобны для использования, но обладают рядом существенных 
      недостатков: 
    <ul type="square">
      <br>
      <li> 
        <p align="JUSTIFY"> Операции чтения и записи не&nbsp;анализируют содержимое 
          передаваемых данных. Процесс, прочитавший 20 байт из потока, не может 
          сказать, были ли они записаны одним процессом или несколькими, записывались 
          ли они за один раз или было, например, выполнено 4 операции записи по 
          5 байт. Данные в потоке никак не интерпретируются системой. Если требуется 
          какая-либо интерпретация данных, то передающий и принимающий процесс 
          должны заранее согласовать свои действия и уметь осуществлять ее самостоятельно. 
      </li>
      <li> 
        <p align="JUSTIFY"> Для передачи информации от одного процесса к другому 
          требуется, как минимум, две операции копирования данных: первый раз 
          - из адресного пространства передающего процесса в системный буфер, 
          второй раз - из системного буфера в адресное пространство принимающего 
          процесса. 
      </li>
      <li> 
        <p align="JUSTIFY"><a name="s0601a"></a>Процессы, обменивающиеся информацией, 
          должны одновременно существовать в вычислительной системе. Нельзя записать 
          информацию в поток с помощью одного процесса, завершить его, а затем, 
          через некоторое время, запустить другой процесс и прочитать записанную 
          информацию.&nbsp;&nbsp; 
      </li>
    </ul>
    <br>
    </font> &nbsp; </LI>
  <LI> 
    <p align="JUSTIFY"><font  face="Times New Roman, Times, serif" size="3" color="#FF0000"><b><a name="s0602"></a>Понятие 
      о System V IPC.</b></font> <br>
      <br>
    <p align="JUSTIFY"> <font face="Times New Roman, Times, serif" size="3">Указанные 
      выше недостатки потоков данных привели к разработке других механизмов передачи 
      информации между процессами. Часть этих механизмов, впервые появившихся 
      в UNIX System V и впоследствии перекочевавших оттуда практически во все 
      современные версии операционной системы UNIX, получила общее название <i> 
      System V IPC</i> (IPC - сокращение от InterProcess Communications). В группу 
      System V IPC входят: очереди сообщений, разделяемая память и семафоры. Эти 
      средства организации взаимодействия процессов связаны не только общностью 
      происхождения, но и обладают схожим интерфейсом для выполнения схожих операций, 
      например для выделения и освобождения соответствующего ресурса в системе. 
      Их рассмотрение мы будем проводить в порядке от менее семантически нагруженных 
      с точки зрения операционной системы к более семантически нагруженным. Иными 
      словами, чем позже мы будем заниматься каким-либо механизмом&nbsp; из System 
      V IPC, тем больше действий по интерпретации передаваемой информации приходится 
      выполнять операционной системе при использовании этого механизма. Часть 
      этого семинара мы посвятим изучению разделяемой памяти. Семафоры будут рассматриваться 
      на <a href="../../08/prep/sem8.htm">семинаре 8</a>, а очереди сообщений 
      - на <a href="../../09/prep/sem9.htm">семинаре 9</a>.</font> <br>
      &nbsp; 
  </li>
  <LI> 
    <p align="JUSTIFY"><font  face="Times New Roman, Times, serif" size="3" color="#FF0000"><b><a name="s0603"></a> 
      Пространство имен. Адресация в System V IPC. Функция ftok().</b></font> 
      <br>
      <br>
    <font face="Times New Roman, Times, serif" size="3"> 
    <p align="JUSTIFY"><a href="../../04/ch4.htm#l040301a"><img border="0" src="../../images/bookopen.gif" 
    alt="Прямая и непрямая адресация в лекции" align="right" hspace="10" vspace="1" width="48" height="34"></a>Все 
      средства связи из System V IPC, как и уже рассмотренные нами pipe и FIFO, 
      являются средствами связи с непрямой адресацией. Как мы установили&nbsp; 
      <a href="../../05/prep/sem5.htm#s0514a">ранее</a>, на <a href="../../05/prep/sem5.htm"> 
      предыдущем семинаре</a>,&nbsp;для организации взаимодействия неродственных 
      процессов с помощью средства связи с непрямой адресацией необходимо, чтобы 
      это средство связи имело некоторое имя.&nbsp;Отсутствие имен у pip'ов позволяет 
      процессам получать информацию о расположении pip'а в системе и его состоянии 
      только через родственные связи. Наличие ассоциированного имени у FIFO - 
      имени специализированного файла в файловой системе - позволяет неродственным 
      процессам получать эту информацию через интерфейс файловой системы.&nbsp;<br>
      <br>
      Множество всех возможных имен для объектов какого-либо вида принято называть 
      <i>пространством имен</i> соответствующего вида объектов. Для FIFO пространством 
      имен является множество всех допустимых имен файлов в файловой системе. 
      Для всех объектов из System V IPC таким пространством имен является множество 
      значений некоторого целочисленного типа данных -<font color="#008000"><b> 
      key_t</b></font>. - ключа. Причем программисту не позволено напрямую присваивать 
      значение ключа, это значение задается опосредовано: через комбинацию имени 
      какого-либо файла, уже существующего в файловой системе, и небольшого целого 
      числа - например, номера экземпляра средства связи.<br>
      <br>
      Такой хитрый способ получения значения ключа связан с двумя соображениями: 
    </font> 
    <ul type="square">
      <br>
      <font face="Times New Roman, Times, serif" size="3"> 
      <li> 
        <p align="JUSTIFY"> Если разрешить программистам самим впрямую присваивать 
          значение ключа для идентификации средств связи, то не исключено, что 
          два различных программиста случайно воспользуются одним и тем же значением, 
          не подозревая об этом. Тогда их процессы будут несанкционированно взаимодействовать 
          через одно и то же средство коммуникации, что может привести к незапланированному 
          поведению этих процессов. Поэтому основным компонентом значения ключа 
          является преобразованное в числовое значение полное имя некоторого файла, 
          доступ к которому на чтение разрешен процессу. Каждый программист имеет 
          возможность использовать для этой цели свой специфический файл, например, 
          исполняемый файл, связанный с одним из его взаимодействующих процессов. 
          Следует отметить, что преобразование из текстового имени файла в число 
          основывается на расположении указанного файла на жестком диске или ином 
          физическом носителе. Поэтому для образования ключа следует применять 
          файлы, не меняющие своего положения в течение времени организации взаимодействия 
          процессов. 
      </li>
      <li> 
        <p align="JUSTIFY">Второй компонент значения ключа используется для того, 
          чтобы позволить программисту связать с одним и тем же именем файла более 
          одного экземпляра каждого средства связи. В качестве такого компонента 
          можно задавать порядковый номер соответствующего экземпляра. 
      </li>
      </font><br>
    </ul>
    <p align="JUSTIFY"><font face="Times New Roman, Times, serif" size="3"> Получение 
      значения ключа из двух этих компонентов осуществляется функцией <a href="../../man/ftok.htm">ftok()</a>. 
      <br>
      <br>
      <img border="0" src="../../images/znak.gif" align="left" vspace="8" alt="Nota bene" hspace="10">Необходимо 
      еще раз подчеркнуть три важных момента, связанных с использованием имени 
      файла для получения ключа. Во-первых, необходимо указывать имя файла, который 
      <b>уже существует</b> в файловой системе и для которого процесс <b>имеет 
      право доступа на чтение</b> (не путайте с заданием имени файла при создании 
      FIFO, где указывалось имя <b>для вновь создаваемого </b>специального файла). 
      Во-вторых, указанный файл должен<b> сохранять свое положение на диске </b>до 
      тех пор, пока все процессы, участвующие во взаимодействии, не получат ключ 
      System V IPC. В-третьих, задание имени файла, как одной из компонент для 
      получения ключа, ни в коем случае не означает, что информация, передаваемая 
      с помощью ассоциированного средства связи, будет располагаться в этом файле. 
      Информация будет храниться <b>внутри адресного пространства операционной 
      системы</b>, а заданное имя файла лишь позволяет различным процессам сгенерировать 
      идентичные ключи.<br>
      </font> <br>
      &nbsp; 
  </li>
  <LI> 
    <p align="JUSTIFY"><font  face="Times New Roman, Times, serif" size="3" color="#FF0000"><b><a name="s0604"></a>Дескрипторы 
      System V IPC.</b></font> <br>
      <br>
    <p align="JUSTIFY"> <font face="Times New Roman, Times, serif" size="3"> <a href="../../05/prep/sem5.htm#s0503">Мы 
      говорили</a>, что информацию о потоках ввода-вывода, с которыми имеет дело 
      текущий процесс, в частности о pip'ах и FIFO, операционная система хранит 
      в таблице открытых файлов процесса. Системные вызовы, осуществляющие операции 
      над потоком, используют в качестве параметра индекс элемента таблицы открытых 
      файлов, соответствующего потоку, - файловый дескриптор. Использование файловых 
      дескрипторов для идентификации потоков внутри процесса позволяет применять 
      к ним уже существующий интерфейс для работы с файлами, но в то же время 
      приводит к автоматическому закрытию потоков при завершении процесса. Этим 
      в частности, объясняется <a href="#s0601a">один из недостатков</a> потоковой 
      передачи информации. <br>
      <br>
      При реализации компонент System V IPC была принята другая концепция. Ядро 
      операционной системы хранит информацию обо всех средствах System V IPC, 
      используемых в системе, вне контекста пользовательских процессов. При создании 
      нового средства связи или получении доступа к уже существующему процесс 
      получает неотрицательное целое число - <i>дескриптор (идентификатор) этого 
      средства связи</i>, которое однозначно идентифицирует его во всей вычислительной 
      системе. Этот дескриптор должен передаваться в качестве параметра всем системным 
      вызовам, осуществляющим дальнейшие операции над соответствующим средством 
      System V IPC. <br>
      <br>
      Подобная концепция позволяет устранить один из самых существенных недостатков, 
      присущих потоковым средствам связи - требование об одновременном существовании 
      взаимодействующих процессов, но в то же время требует повышенной осторожности 
      для того, чтобы процесс, получающий информацию, не принял взамен новых старые, 
      уже &quot;протухшие&quot; данные, по забывчивости оставленные в механизме 
      коммуникации.<br>
      </font> &nbsp; 
  </li>
  <li> 
    <p align="JUSTIFY"><font  face="Times New Roman, Times, serif" size="3" color="#FF0000"><b><a name="s0605"></a>Разделяемая 
      память в UNIX. Системные вызовы shmget(), shmat(), shmdt().</b></font> <br>
      <br>
    <p align="JUSTIFY"> 
    <font face="Times New Roman, Times, serif" size="3"><a href="../../04/ch4.htm#l0402"><img border="0" src="../../images/bookopen.gif" 
    alt="Разделяемая память в лекции" align="right" hspace="10" vspace="1" width="48" height="34"></a>С 
    точки зрения операционной системы, наименее семантически нагруженным средством 
    System V IPC является разделяемая память (shared memory). Мы уже упоминали 
    об этой категории средств связи на лекции. Для текущего семинара нам достаточно 
    знать, что операционная система может позволить нескольким процессам совместно 
    использовать некоторую область адресного пространства. Внутренние механизмы, 
    позволяющие реализовать такое использование, будут подробно рассмотрены на 
    лекции, посвященной сегментной, страничной и сегментно-страничной организации 
    памяти. <br>
    <br>
    <a href="../../04/ch4.htm#l040301"><img border="0" src="../../images/bookopen.gif" 
    alt="Инициализация средств связи в лекции" align="right" hspace="10" vspace="1" width="48" height="34"></a> 
    Все средства связи System V IPC требуют предварительных инициализирующих действий 
    (своего создания) для организации взаимодействия процессов.<br>
    <br>
    <a name="s0605a"></a>Для создания области разделяемой памяти с определенным 
    ключом или доступа по ключу к уже существующей области применяется системный 
    вызов <a href="../../man/shmget.htm">shmget()</a>. Существует два варианта 
    его использования для создания новой области разделяемой памяти.<br>
    <br>
    <ul type="square">
      <li> 
        <p align="JUSTIFY"> Стандартный способ. В качестве значения ключа системному 
          вызову поставляется значение, сформированное функцией <a href="../../man/ftok.htm">ftok()</a> 
          для некоторого имени файла и номера экземпляра области разделяемой памяти. 
          В качестве флагов поставляется комбинация прав доступа к создаваемому 
          сегменту и флага <b><font color="#008000">IPC_CREAT</font></b>. Если 
          сегмент для данного ключа еще не существует, то система будет пытаться 
          создать его с указанными правами доступа. Если же вдруг он уже существовал, 
          то мы просто получим его дескриптор. Возможно добавление к этой комбинации 
          флагов флага<b><font color="#008000"> IPC_EXCL</font></b>. Этот флаг 
          гарантирует нормальное завершение системного вызова только в том случае, 
          если сегмент действительно был создан (т.&nbsp;е. ранее он не существовал), 
          если же сегмент существовал, то системный вызов завершится с ошибкой, 
          и значение системной переменной <font color="#008000"><b>errno</b></font>, 
          описанной в файле <font color="#008000"><b>errno.h</b></font>, будет 
          установлено в <font color="#008000"><b>EEXIST</b></font>. 
      </li>
      <li> 
        <p align="JUSTIFY">Нестандартный способ. В качестве значения ключа указывается 
          специальное значение <b><font color="#008000">IPC_PRIVATE</font></b>.<FONT FACE="Times New Roman"> 
          Использование значения<b><font color="#008000"> IPC_PRIVATE</font></b> 
          <b><u>всегда</u></b> приводит к попытке создания нового сегмента разделяемой 
          памяти с заданными правами доступа и с ключом, который не совпадает 
          со значением ключа ни одного из уже существующих сегментов и который 
          не может быть получен с помощью функции <a href="../../man/ftok.htm">ftok()</a> 
          ни при одной комбинации ее параметров. Наличие флагов </font><font face="Times New Roman, Times, serif" size="3"><b><font color="#008000">IPC_CREAT</font></b> 
          и <b><font color="#008000">IPC_EXCL</font></b> в этом случае игнорируется.</font> 
      </li>
    </ul>
    <br>
    Доступ к созданной области разделяемой памяти в дальнейшем обеспечивается 
    ее дескриптором, который вернет системный вызов <a href="../../man/shmget.htm">shmget()</a>. 
    Доступ к уже существующей области также может быть осуществлен двумя способами:<br>
    <br>
    <ul type="square">
      <li> 
        <p align="JUSTIFY"> Если мы знаем ее ключ, то, использовав вызов <a href="../../man/shmget.htm">shmget()</a>, 
          мы можем получить ее дескриптор. В этом случае нельзя использовать в 
          качестве составной части флагов флаг <font face="Times New Roman, Times, serif" size="3"><b><font color="#008000">IPC_EXCL</font></b></font>, 
          а значение ключа, естественно, не может быть <b><font color="#008000">IPC_PRIVATE</font></b>. 
          Права доступа игнорируются, а размер области должен совпадать с размером, 
          указанным при ее создании. 
      </li>
      <li> 
        <p align="JUSTIFY">Либо мы можем воспользоваться тем, что дескриптор System 
          V IPC действителен в рамках всей операционной системы, и передать его 
          значение от процесса, создавшего разделяемую память, каким-нибудь образом 
          текущему процессу. Отметим, что при создании разделяемой памяти с помощью 
          значения <font face="Times New Roman, Times, serif" size="3"><FONT FACE="Times New Roman"><b><font color="#008000">IPC_PRIVATE 
          </font></b> - это единственно возможный способ.</font></font> 
      </li>
    </ul>
    <br>
    <p align="JUSTIFY"> После получения дескриптора необходимо включить область 
      разделяемой памяти в адресное пространство текущего процесса. Это осуществляется 
      с помощью системного вызова <a href="../../man/shmat.htm">shmat()</a>. При 
      нормальном завершении он вернет адрес разделяемой памяти в адресном пространстве 
      текущего процесса. Дальнейший доступ к этой памяти осуществляется с помощью 
      обычных средств языка программирования. После окончания использования разделяемой 
      памяти процесс может уменьшить размер своего адресного пространства, исключив 
      из него эту область с помощью системного вызова <a href="../../man/shmdt.htm">shmdt()</a>. 
      Отметим, что в качестве своего параметра системный вызов <a href="../../man/shmdt.htm">shmdt()</a> 
      требует адрес начала области разделяемой памяти в адресном пространстве 
      процесса, т.&nbsp;е. значение, которое вернул системный вызов <a href="../../man/shmat.htm">shmat()</a>, 
      поэтому данное значение следует сохранять на протяжении всего времени использования 
      разделяемой памяти.<br>
      &nbsp; <br>
    </font> </li>
  <li> 
    <p align="JUSTIFY"><font  face="Times New Roman, Times, serif" size="3" color="#FF0000"><b><a name="s0606"></a>Прогон 
      программ с использованием разделяемой памяти.</b></font> <br>
      <br>
    <p align="JUSTIFY"><font  face="Times New Roman, Times, serif" size="3">Для 
      иллюстрации использования разделяемой памяти давайте рассмотрим <a href="../stud/06-1c.htm">две 
      взаимодействующие программы</a>, расположенные в файлах /ftp/pub/sem6-7/stud/06-1a.c 
      и /ftp/pub/sem6-7/stud/06-1b.c. Обе программы очень похожи друг на друга 
      и используют разделяемую память для хранения числа запусков каждой из программ 
      и их суммы. В разделяемой памяти размещается массив из трех целых чисел. 
      Первый элемент массива используется как счетчик для <a href="../stud/06-1ca.htm">программы 
      1,</a> второй элемент - для <a href="../stud/06-1cb.htm">программы 2</a>, 
      третий элемент - для обеих программ суммарно. Дополнительный нюанс в программах 
      возникает из-за необходимости инициализации элементов массива при создании 
      разделяемой памяти. Для этого нам нужно, чтобы программы могли различать 
      случай, когда они создали ее и случай, когда она уже существовала. Мы добиваемся 
      различия, используя вначале системный вызов <a href="../../man/shmget.htm">shmget()</a> 
      с флагами <font color="#008000"><b>IPC_CREAT</b></font> и <font color="#008000"><b>IPC_EXCL</b></font>. 
      Если вызов завершается нормально, то мы создали разделяемую память. Если 
      вызов завершается с констатацией ошибки&nbsp; и значение переменной <font color="#008000"><b>errno</b></font> 
      равняется <font color="#008000"><b>EEXIST</b></font>, то, значит, разделяемая 
      память уже существует, и мы можем получить ее IPC дескриптор, применяя тот 
      же самый вызов с нулевым значением флагов. Откомпилируйте программы и запустите 
      их несколько раз. Проанализируйте полученные результаты. <br>
      &nbsp; <br>
      </font> 
  </li>
  <li> 
    <p align="JUSTIFY"><font  face="Times New Roman, Times, serif" size="3" color="#FF0000"><b><a name="s0607"></a>Команды 
      ipc и ipcrm. </b></font> <br>
      <br>
    <p align="JUSTIFY"> 
    <font  face="Times New Roman, Times, serif" size="3">Как мы видели из предыдущего 
    примера, созданная область разделяемой памяти сохраняется в операционной системе 
    даже тогда, когда нет ни одного процесса,&nbsp; включающего ее в свое адресное 
    пространство. С одной стороны, это имеет определенные преимущества, не требуя 
    одновременного существования взаимодействующих процессов, с другой стороны 
    может причинять существенные неудобства. Допустим, что предыдущие <a href="../stud/06-1c.htm">программы</a> 
    мы хотим использовать таким образом, чтобы подсчитывать количество запусков 
    в течение&nbsp; одного, текущего, сеанса работы в системе. Однако в созданном 
    сегменте разделяемой памяти остается информация от предыдущего сеанса, и программы 
    будут выдавать общее количество запусков за все время работы с момента загрузки 
    операционной системы. Можно было бы создавать для нового сеанса новый сегмент 
    разделяемой памяти, но количество ресурсов в системе не безгранично. Нас спасает 
    то, что существуют способы удалять неиспользуемые ресурсы System V IPC как 
    с помощью команд операционной системы, так и с помощью системных вызовов. 
    <a href="../../04/ch4.htm#l040305"><img border="0" src="../../images/bookopen.gif" 
    alt="Завершение взаимодействия в лекции" align="right" hspace="10" vspace="1" width="48" height="34"></a> 
    Все средства System V IPC требуют определенных действий для освобождения занимаемых 
    ресурсов после окончания взаимодействия процессов. Для того, чтобы удалять 
    ресурсы System V IPC из командной строки, нам понадобятся две команды <a href="../../man/ipcs.htm"> 
    ipcs</a> и <a href="../../man/ipcrm.htm">ipcrm</a>. Команда <a href="../../man/ipcs.htm"> 
    ipcs</a> выдает информацию обо всех средствах System V IPC, существующих в 
    системе, для которых пользователь обладает правами на чтение: областях разделяемой 
    памяти, семафорах и очередях сообщений. Из всего многообразия выводимой информации 
    нас будут интересовать только IPC идентификаторы для средств, созданных вами. 
    Эти идентификаторы будут использоваться в команде <a href="../../man/ipcrm.htm">ipcrm</a>, 
    позволяющей удалить необходимый ресурс из системы. Для удаления сегмента разделяемой 
    памяти эта команда имеет вид: 
    <p align="center"><b> <font color="#008000"><a href="../../man/ipcrm.htm">ipcrm</a> 
      shm &lt;IPC идентификатор</font></b>&gt;&nbsp;&nbsp;<br>
      <br>
    </font> 
    <p align="JUSTIFY"><font face="Times New Roman, Times, serif" size="3">Удалите 
      созданный вами сегмент разделяемой памяти из операционной системы, используя 
      эти команды. <br>
      <br>
      <img border="0" src="../../images/znak.gif" align="left" vspace="2" alt="Nota bene" hspace="10"> 
      Если поведение ваших программ, использующих средства System V IPC, базируется 
      на предположении, что эти средства были созданы при их работе, не забывайте 
      перед их запуском удалять уже существовавшие ресурсы. <br>
      &nbsp; <br>
      </font> 
  </li>
  <li> 
    <p align="JUSTIFY"><font  face="Times New Roman, Times, serif" size="3" color="#FF0000"><b><a name="s0608"></a>Использование 
      системного вызова shmctl() для освобождения ресурса.</b></font> <br>
      <br>
    <p align="JUSTIFY"><font face="Times New Roman, Times, serif" size="3"> Для 
      той же цели - удалить область разделяемой памяти из системы - можно воспользоваться 
      и системным вызовом <a href="../../man/shmctl.htm">shmctl()</a>. Этот системный 
      вызов позволяет полностью ликвидировать область разделяемой памяти в операционной 
      системе по заданному дескриптору средства IPC, если, конечно, у вас хватает 
      для этого полномочий. Кроме этого, системный вызов <a href="../../man/shmctl.htm">shmctl()</a> 
      позволяет выполнять и другие действия над сегментом разделяемой памяти, 
      но их изучение лежит за пределами нашего курса. </font><font face="Times New Roman, Times, serif" size="3"><br>
      &nbsp; <br>
      </font> 
  </li>
  <li> 
    <p align="JUSTIFY"><font  face="Times New Roman, Times, serif" size="3" color="#FF0000"><b><a name="s0609"></a>Разделяемая 
      память и системные вызовы fork(), exec() и функция exit().</b></font> <br>
      <br>
    <p align="JUSTIFY"><font face="Times New Roman, Times, serif" size="3"> Важным 
      вопросом является поведение сегментов разделяемой памяти при выполнении 
      процессом системных вызовов<a href="../../man/fork.htm"> fork()</a>, <a href="../../man/exec.htm">exec()</a> 
      и функции <a href="../../man/exit.htm">exit()</a>.<br>
      <br>
      При выполнении системного вызова <a href="../../man/fork.htm">fork()</a> 
      все области разделяемой памяти, размещенные в адресном пространстве процесса, 
      наследуются порожденным процессом.<br>
      <br>
      При выполнении системных вызовов <a href="../../man/exec.htm">exec()</a> 
      и функции <a href="../../man/exit.htm">exit()</a> все области разделяемой 
      памяти, размещенные в адресном пространстве процесса, исключаются из его 
      адресного пространства, но продолжают существовать в операционной системе. 
      <br>
      &nbsp; <br>
      </font> 
  </li>
  <li> 
    <p align="JUSTIFY"><font  face="Times New Roman, Times, serif" size="3" color="#FF0000"><b><a name="s0610"></a>Самостоятельное 
      написание, компиляция и запуск программы для организации связи двух процессов 
      через разделяемую память.</b></font> <br>
      <br>
    <p align="JUSTIFY"><font face="Times New Roman, Times, serif" size="3"> 
      Для закрепления полученных знаний напишите две программы, осуществляющие 
      взаимодействие через разделяемую память. Первая программа должна создавать 
      сегмент разделяемой памяти и копировать туда свой собственный исходный текст, 
      вторая программа должна брать оттуда этот текст, печатать его на экране 
      и удалять сегмент разделяемой памяти из системы.<br>
      &nbsp; <br>
      </font> 
  </li>
  <li> 
    <p align="JUSTIFY"><font  face="Times New Roman, Times, serif" size="3" color="#FF0000"><b><a name="s0611"></a>Понятие 
      о нити исполнения (thread) в UNIX. Идентификатор нити исполнения. Функция 
      pthread_self().</b></font> <br>
      <br>
    <p align="JUSTIFY"><font face="Times New Roman, Times, serif" size="3"><a href="../../04/ch4.htm#l0404"><img border="0" src="../../images/bookopen.gif" 
    alt="Нити исполнения в лекции" align="right" hspace="10" vspace="1" width="48" height="34"></a> 
      На лекции мы говорили, что во многих современных операционных системах существует 
      расширенная реализация понятия процесс, когда процесс представляет собой 
      совокупность выделенных ему ресурсов и набора нитей исполнения. Нити процесса 
      разделяют его программный код, глобальные переменные и системные ресурсы, 
      но каждая нить имеет свой собственный программный счетчик, свое содержимое 
      регистров и свой собственный стек. Поскольку глобальные переменные у нитей 
      исполнения являются общими, то они могут использовать их, как элементы разделяемой 
      памяти, не прибегая к механизму, описанному выше.<br>
      <br>
      В различных версиях операционной системы UNIX существуют различные интерфейсы, 
      обеспечивающие работу с нитями исполнения. Мы с вами кратко ознакомимся 
      с некоторыми функциями, позволяющими разделить процесс на thread'ы и управлять 
      их поведением, соответствующими стандарту POSIX. Нити исполнения, удовлетворяющие 
      стандарту POSIX, принято называть POSIX thread'ами или кратко pthread'ами.<br>
      <br>
      <a href="../../04/ch4.htm#l0404a"><img border="0" src="../../images/bookopen.gif" 
    alt="Реализация нитей исполнения в лекции" align="right" hspace="10" vspace="1" width="48" height="34"></a>К 
      сожалению, операционная система Linux не полностью поддерживает нити исполнения 
      на уровне ядра системы. При создании нового thread'а запускается новый традиционный 
      процесс, разделяющий с родительским традиционным процессом его ресурсы, 
      программный код и данные, расположенные вне стека, т.е. фактически действительно 
      создается новый thread, но ядро не умеет определять, что эти thread'ы являются 
      составными частями одного целого. Это знает только специальный процесс-координатор, 
      работающий на пользовательском уровне и стартующий при первом вызове функций, 
      обеспечивающих POSIX интерфейс для нитей исполнения. Поэтому мы сможем наблюдать 
      не все преимущества использования нитей исполнения (в частности, ускорить 
      решение задачи с их помощью вряд ли получится), но даже в этом случае, thread'ы 
      можно использовать как очень удобный способ для создания процессов с общими 
      ресурсами, программным кодом и разделяемой памятью.<br>
      <br>
      Каждая нить исполнения, как и процесс, имеет в системе свой собственный 
      уникальный номер - идентификатор thread'a. Поскольку традиционный процесс 
      в концепции нитей исполнения трактуется как процесс, содержащий единственную 
      нить исполнения, то мы можем узнать идентификатор этой нити и для любого 
      обычного процесса. Для этого используется функция<a href="../../man/pthread1.htm"> 
      pthread_self()</a>. Нить исполнения создаваемую при рождении нового процесса 
      принято называть <i>начальной</i> или <i> главной нитью исполнения</i> этого 
      процесса.<br>
      &nbsp; <br>
      </font> 
  </li>
  <li> 
    <p align="JUSTIFY"><font  face="Times New Roman, Times, serif" size="3" color="#FF0000"><b><a name="s0612"></a>Создание 
      и завершение thread'а. Функции pthread_create(), pthread_exit(), pthread_join().</b></font> 
      <br>
      <br>
    <p align="JUSTIFY"> 
    <font face="Times New Roman, Times, serif" size="3"> Нити исполнения, как 
    и традиционные процессы, могут порождать нити-потомки, правда, только внутри 
    своего процесса. Каждый будущий thread внутри программы должен представлять 
    собой функцию с прототипом <br>
    <br>
    <p align="CENTER"><font color="#008000"><b><i>void *thread(void *arg); </i></b></font><br>
      <br>
    <p align="JUSTIFY">Параметр <b><font color="#008000"><i>arg</i></font></b> 
      передается этой функции при создании thread'a и может, до некоторой степени, 
      рассматриваться как аналог параметров функции <b> <font color="#008000"><i>main()</i></font></b>, 
      о которых мы говорили на <a href="../../03/prep/sem3-4.htm#s0311">семинарах 
      3-4</a>. Возвращаемое функцией значение может интерпретироваться как аналог 
      информации, которую родительский процесс может получить после завершения 
      процесса-ребенка. Для создания новой нити исполнения применяется функция 
      <a href="../../man/pthread2.htm">pthread_create()</a>. Мы не будем рассматривать 
      ее в полном объеме, так как детальное изучение программирования с использованием 
      thread'ов не является целью данного курса. <img border="0" src="../../images/znak.gif" align="left" vspace="2" alt="Nota bene" hspace="10"> 
      Важным отличием этой функции от большинства других системных вызовов и функций 
      является то, что в случае неудачного завершения она <b><u> возвращает не 
      отрицательное, а положительное значение</u></b>, которое определяет код 
      ошибки, описанный в файле <font color="#008000">errno.h</font>. Значение 
      системной переменной <font color="#008000"><b>errno</b></font> при этом 
      не устанавливается. Результатом выполнения этой функции является появление 
      в системе новой нити исполнения, которая будет выполнять функцию, ассоциированную 
      со thread'ом, передав ей специфицированный параметр, параллельно с уже существовавшими 
      нитями исполнения процесса.<br>
      <br>
      &nbsp;Созданный thread может завершить свою деятельность тремя способами<br>
    </font> 
    <ul type="square">
      <li> 
        <p align="JUSTIFY"><font face="Times New Roman" size="3">С помощью выполнения 
          функции <a href="../../man/pthread3.htm">pthread_exit()</a>. Функция 
          никогда не возвращается в вызвавшую ее нить исполнения. Объект, на который 
          указывает параметр этой функции, может быть изучен в другой нити исполнения, 
          например, в породившей завершившийся thread. Этот параметр, следовательно, 
          должен указывать на объект, не являющийся локальным для завершившегося 
          thread'а, например, на статическую переменную. </FONT> 
      </li>
      <li> 
        <p align="JUSTIFY"><font face="Times New Roman" size="3">С помощью возврата 
          из функции, ассоциированной с нитью исполнения. Объект, на который указывает 
          адрес, возвращаемый функцией, как и в предыдущем случае, может быть 
          изучен в другой нити исполнения, например, в породившей завершившийся 
          thread, и должен указывать на объект, не являющийся локальным для завершившегося 
          thread'а.</font> 
      </li>
      <li> 
        <p align="JUSTIFY"> <font face="Times New Roman, Times, serif" size="3">Если 
          в процессе выполняется возврат из функции <font color="#008000"><b> 
          main()</b></font> или где-либо в процессе (в любой нити исполнения) 
          осуществляется вызов функции <a href="../../man/exit.htm">exit()</a>, 
          то это приводит к завершению всех thread'ов процесса. </font> 
      </li>
    </ul>
  <font face="Times New Roman, Times, serif" size="3"><br>
  <p align="JUSTIFY">Одним из вариантов получения адреса, возвращаемого завершившимся 
    thread'ом, с одновременным ожиданием его завершения является использование 
    функции <a href="../../man/pthread4.htm">pthread_join()</a>. Нить исполнения, 
    вызвавшую эту функцию, переходит в состояние <i><b>ожидание </b></i>до завершения 
    заданного thread'а. Функция позволяет также получить указатель, который вернул 
    завершившийся thread в операционную систему. &nbsp; </p>
  <li> 
    <p align="JUSTIFY"><font  color="#FF0000"><b><a name="s0613"></a>Прогон программы 
      с использованием двух нитей исполнения.</b></font> <br>
      <br>
      Для иллюстрации вышесказанного давайте рассмотрим <a href="../stud/06-2c.htm">программу</a> 
      /ftp/pub/sem6-7/stud/06-2.c, в которой работают две нити исполнения. При 
      работе редактора связей&nbsp; необходимо явно подключить библиотеку функции 
      для работы с pthread'ами, которая не подключается автоматически. Это делается 
      с помощью добавления к команде компиляции и редактирования связей параметра 
      <font color="#008000"><b> -lpthread</b></font> - подключить библиотеку pthread. 
      Откомпилируйте эту программу и запустите на исполнение. <img border="0" src="../../images/znak.gif" align="left" vspace="8" alt="Nota bene" hspace="10">Обратите 
      внимание на отличие результатов этой программы от <a href="../../03/stud/03-1c.htm">похожей 
      программы</a>, иллюстрировавшей создание нового процесса, которую мы рассматривали 
      на <a href="../../03/prep/sem3-4.htm#s0308">семинарах 3-4</a>. Программа, 
      создававшая новый процесс, печатала дважды одинаковые значения для переменной 
      <i><b><font color="#008000">a</font></b></i>, так как адресные пространства 
      различных процессов независимы, и каждый процесс прибавлял <b><font color="#008000">1 
      </font></b>к своей собственной переменной<i><b><font color="#008000"> a</font></b></i>. 
      Рассматриваемая программа печатает два разных значения, так как переменная 
      <i><b><font color="#008000">a</font></b></i> является разделяемой, и каждый 
      thread прибавляет <b><font color="#008000">1</font></b> к одной и той же 
      переменной. 
    <p align="JUSTIFY"><font face="Times New Roman, Times, serif" size="3"> &nbsp; 
      </font> 
  </li>
  <li> 
    <p align="JUSTIFY"><font  face="Times New Roman, Times, serif" size="3" color="#FF0000"><b><a name="s0614"></a>Написание, 
      компиляция и прогон программы с использованием трех нитей исполнения.</b></font> 
      <br>
      <br>
     
      Модифицируйте предыдущую программу, добавив к ней третью нить исполнения. 
    <p align="JUSTIFY"><font face="Times New Roman, Times, serif" size="3"> &nbsp; 
      </font> 
  </li>
  <li> 
    <p align="JUSTIFY"><font  face="Times New Roman, Times, serif" size="3" color="#FF0000"><b><a name="s0615"></a>Необходимость 
      синхронизации процессов и нитей исполнения, использующих общую память.</b></font> 
      <br>
      <br>
    <p align="JUSTIFY"> 
    <font face="Times New Roman, Times, serif" size="3"> <a href="../../05/ch5.htm#l0502"><img border="0" src="../../images/bookopen.gif" 
    alt="Критическая секция в лекции" align="right" hspace="10" vspace="1" width="48" height="34"></a> 
    Все рассмотренные на этом семинаре примеры являются не совсем корректными. 
    В большинстве случаев они работают правильно, однако возможны ситуации, когда 
    совместная деятельность этих процессов или нитей исполнения приводит к неверным 
    и неожиданным результатом. Это связано с тем, что любые неатомарные операции, 
    связанные с изменением содержимого разделяемой памяти, представляют собой 
    критическую секцию процесса или нити исполнения. Вернемся к рассмотрению <a href="../stud/06-1c.htm">программ</a> 
    /ftp/pub/sem6-7/stud/06-1a.c и /ftp/pub/sem6-7/stud/06-1b.c. При одновременном 
    существовании 2-х процессов в операционной системе может возникнуть следующая 
    последовательность выполнения операций во времени: <br>
    <br>
    <dir> 
      <dir> 
        <dir><i><b><font color="#008000"> ...<br>
          Процесс 1: array[0] += 1;<br>
          Процесс 2: array[1] += 1;<br>
          Процесс 1: array[2] += 1;<br>
          Процесс 1: printf("Program 1 was spawn %d times, program 2 - %d times, 
          total - %d times\n", array[0], array[1], array[2]);<br>
          ...</font></b></i><br>
        </dir>
      </dir>
    </dir>
    <br>
    </font> 
    <p align="JUSTIFY"><font face="Times New Roman, Times, serif" size="3">Тогда 
      печать будет давать неправильные результаты. Естественно, что воспроизвести 
      подобную последовательность действий практически нереально. Мы не сможем 
      подобрать необходимые времена старта процессов и степень загруженности вычислительной 
      системы. Но мы можем смоделировать эту ситуацию, добавив в обеих программах 
      достаточно длительные пустые циклы перед оператором <font face="Times New Roman, Times, serif" size="3"><i><b><font color="#008000"> 
      array[2] += 1;</font></b></i></font> Это проделано в <a href="../stud/06-3c.htm">программах</a> 
      <font face="Times New Roman, Times, serif" size="3">/ftp/pub/sem6-7/stud/06-3a.c 
      и /ftp/pub/sem6-7/stud/06-3b.c</font>. Откомпилируем их, запустим любую 
      из них один раз для создания и инициализации разделяемой памяти. Затем запустим 
      другую и, пока она находится в цикле, запустим, например, с другого виртуального 
      терминала, снова первую. Мы получим неожиданный результат. <a href="../../05/ch5.htm#l0503"><img border="0" src="../../images/bookopen.gif" 
    alt="Алгоритмы синхронизации в лекции" align="right" hspace="10" vspace="1" width="48" height="34"></a> 
      Как видим, для написания корректно работающих программ необходимо обеспечивать 
      взаимоисключение при работе с разделяемой памятью и, может быть, взаимную 
      очередность доступа к ней. Это можно сделать с помощью рассмотренных на 
      лекции алгоритмов синхронизации, например, <a href="../../05/ch5.htm#l050306">алгоритма 
      Петерсона</a> или <a href="../../05/ch5.htm#l050307">алгоритма булочной</a>. 
      <br>
      <br>
      </font><font face="Times New Roman, Times, serif" size="2"><b><u>Задача 
      повышенной сложности:</u></b> модифицируйте <a href="../stud/06-3c.htm">программы</a> 
      /ftp/pub/sem6-7/stud/06-3a.c и /ftp/pub/sem6-7/stud/06-3b.c для корректной 
      работы с помощью алгоритма Петерсона.</font><br>
      <br>
      <font face="Times New Roman, Times, serif" size="3">На <a href="../../08/prep/sem8.htm">следующем 
      семинаре</a> мы рассмотрим семафоры, которые являются средством System V 
      IPC, предназначенным для синхронизации процессов.<br>
      &nbsp; </font> 
  </li>
  </font> 
</ol>

 <P align="center"><a href="../../05/prep/sem5.htm"> Предыдущий семинар</a> | <a href="../../os.html">Программа курса</a> | 
 <a href="../../08/prep/sem8.htm"> Следующий семинар</a></P>
</BODY>
</HTML>
