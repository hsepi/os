<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
<TITLE>Семинар 9</TITLE>
</HEAD>
  <BODY bgcolor="#FFFFFF">
 <basefont face="Times New Roman" size="3">
 
 
<P ALIGN="CENTER"><B><FONT FACE="Times New Roman" SIZE = 6>Семинар 9. Очереди 
  сообщений в UNIX.</FONT></B></P>
<P ALIGN="CENTER">(Основывается на <a href="../../04/l4.htm">лекции 4</a> и <a href="../../06/l6.htm">лекции 
  6</a>) </P>
<P align="center"><a href="../../08/prep/sem8.htm"> Предыдущий семинар</a> | <a href="../../os.html">Программа курса</a> | 
 <a href="../../exams/kr1h.htm"> Следующий семинар</a></P>

<FONT FACE="Times New Roman" SIZE=4>  <B><P ALIGN="CENTER">Программа семинара</P> </B></font>
<FONT FACE="Times New Roman" SIZE=3> 
<ol>
  <li><a href="#s0901">
    <P ALIGN="JUSTIFY"><font face="Times New Roman, Times, serif" size="3"> Сообщения 
      как средства связи и средства синхронизации процессов. </font>
    </a></li>
  <li><a href="#s0902">
    <P ALIGN="JUSTIFY"><font face="Times New Roman, Times, serif" size="3"> Очереди 
      сообщений в UNIX как составная часть System V IPC.</font>
    </a></li>
	 <li><a href="#s0903">
    <P ALIGN="JUSTIFY"><font face="Times New Roman, Times, serif" size="3">Создание 
	очереди  сообщений или доступ к уже существующей. 
	Системный вызов msgget().</font>
    </a></li>
		 <li><a href="#s0904">
    <P ALIGN="JUSTIFY"><font face="Times New Roman, Times, serif" size="3">
	Реализация примитивов send и receive. Системные вызовы msgsnd() и msgrcv().
		</font>
    </a></li>
		 <li><a href="#s0905">
    <P ALIGN="JUSTIFY"><font face="Times New Roman, Times, serif" size="3">
	Удаление очереди сообщений из системы с помощью команды 
  ipcrm или системного вызова  msgctl().
		</font>
    </a></li>
		 <li><a href="#s0909">
    <P ALIGN="JUSTIFY"><font face="Times New Roman, Times, serif" size="3">
	Понятие мультиплексирования. Мультиплексирование сообщений.
	Модель взаимодействия процессов клиент-сервер. Неравноправность клиента и сервера.
		</font>
    </a></li>
			 <li><a href="#s0911">
    <P ALIGN="JUSTIFY"><font face="Times New Roman, Times, serif" size="3">
	Использование очередей сообщений для синхронизации работы процессов.
		</font>
    </a></li>
  </ol>
    </font>
  <p align="center">
<font face="Times New Roman, Times, serif" size="3"><B><font size="4">Цели занятия</font></B></font> 
<OL>
    <li>
    <P ALIGN="JUSTIFY"><font face="Times New Roman" size="3">Дать понятие об очередях 
      сообщений в UNIX.</font> 
  </li>
     <li>
    <P ALIGN="JUSTIFY"><font face="Times New Roman" size="3">Привить навыки работы 
      с системными вызовами msgget(), msgsnd(), msgrcv(), msgctl(), </font> 
  </li>
     <li>
    <P ALIGN="JUSTIFY"><font face="Times New Roman" size="3">Студенты должны понять, что сообщения не обязаны быть текстовыми.</font> 
  </li>
      <li>
    <P ALIGN="JUSTIFY"><font face="Times New Roman" size="3">Дать понятие о мультиплексировании и 
	модели клиент-сервер.</font> 
  </li>
</ol>

<P ALIGN="CENTER"><font face="Times New Roman, Times, serif" size="3"><B><font size="4">Практические 
  работы</font></B></font></P>
  
<OL>
  <li>
    <P ALIGN="JUSTIFY"><font face="Times New Roman, Times, serif" size="3"><a href="#s0906"> 
      Прогон примера с однонаправленной передачей текстовой информации.</a></font> 
  </li>
 <li>
    <P ALIGN="JUSTIFY"><font face="Times New Roman, Times, serif" size="3"><a href="#s0907"> 
      Модификация предыдущего примера  для  передачи числовой информации.</a></font> 
  </li>
   <li>
    <P ALIGN="JUSTIFY"><font face="Times New Roman, Times, serif" size="3"><a href="#s0908"> 
    Написание, компиляция и прогон программ для осуществления двусторонней связи 
      через одну очередь сообщений. </a></font> 
  </li>
   <li>
    <P ALIGN="JUSTIFY"><font face="Times New Roman, Times, serif" size="3"><a href="#s0910"> 
     Написание, компиляция и прогон программ клиент и сервер.</a></font> 
  </li>
   
</ol>


<P ALIGN="CENTER"><B><font face="Times New Roman, Times, serif" size="4">План
занятия</font></B></P>
<ol>
  <LI> 
    <p align="JUSTIFY"> <font  face="Times New Roman, Times, serif" size="3" color="#FF0000"><b> 
      <a name="s0901"></a> Сообщения как средства связи и средства синхронизации 
      процессов.</b></font> <br>
      <br>
    <p align="JUSTIFY"> <font face="Times New Roman, Times, serif" size="3"> На 
      предыдущих семинарах мы познакомились с такими средствами организации взаимодействия 
      процессов из состава средств System V IPC, как <a href="../../06/prep/sem6-7.htm">разделяемая 
      память</a> и <a href="../../08/prep/sem8.htm">семафоры</a>. Третьим и последним, 
      наиболее семантически нагруженным средством, входящим в System V IPC, являются 
      <i>очереди сообщений</i>. <a href="../../04/ch4.htm#l04030302c"><img border="0" src="../../images/bookopen.gif" 
    alt="Модель сообшений в лекции" align="right" hspace="10" vspace="1" width="48" height="34"></a>На 
      лекции мы говорили о модели сообщений, как о способе взаимодействия процессов 
      через линии связи, в котором на передаваемую информацию накладывается определенная 
      структура так, что процесс, принимающий данные, может четко определить, 
      где заканчивается одна порция информации и начинается другая. Такая модель 
      позволяет использовать одну и ту же линию связи для передачи данных в двух 
      направлениях между несколькими процессами. <a href="../../06/ch6.htm#l0603"><img border="0" src="../../images/bookopen.gif" 
    alt="Сообщения как механизм синхронизации  в лекции" align="right" hspace="10" vspace="1" width="48" height="34"></a>Мы 
      также говорили о возможности использования сообщений с встроенными механизмами 
      взаимоисключения и блокировки при чтении из пустого буфера и записи в переполненный 
      буфер для организации синхронизации процессов.<br>
      <br>
      На этом семинаре мы познакомимся с использованием очередей сообщений System 
      V IPC для обеспечения обеих этих функций.</font><br>
      &nbsp; 
  </LI>
  <LI> 
    <p align="JUSTIFY"><font  face="Times New Roman, Times, serif" size="3" color="#FF0000"><b><a name="s0902"></a> 
      Очереди сообщений в UNIX как составная часть System V IPC. </b></font> <br>
      <br>
    <p align="JUSTIFY"> <font face="Times New Roman, Times, serif" size="3"> <font face="Times New Roman, Times, serif" size="3">Так 
      как очереди сообщений входят в состав средств System V IPC, то для них верно 
      все, что говорилось <font face="Times New Roman, Times, serif" size="3"><a href="../../06/prep/sem6-7.htm#s0602">ранее</a></font> 
      об этих средствах в целом и уже знакомо нам. <font face="Times New Roman, Times, serif" size="3">Очереди 
      сообщений, как и семафоры, как и разделяемая память, являются средством 
      связи с непрямой адресацией, требуют инициализации для организации взаимодействия 
      процессов и специальных действий для освобождения системных ресурсов по 
      окончании взаимодействия. Пространством имен очередей сообщений является 
      то же самое множество значений <a href="../../06/prep/sem6-7.htm#s0603">ключа</a>, 
      генерируемых с помощью функции <a href="../../man/ftok.htm">ftok()</a>. 
      Для выполнения примитивов <b> <font color="#008000">send</font></b> и<b><font color="#008000"> 
      receive</font></b> соответствующим системным вызовам в качестве параметра 
      передаются <a href="../../06/prep/sem6-7.htm#s0604">IPC дескрипторы</a> 
      очередей сообщений, однозначно идентифицирующих их во всей вычислительной 
      системе.</font></font> <br>
      <br>
      Очереди сообщений располагаются в адресном пространстве ядра операционной 
      системы в виде однонаправленных списков и имеют ограничение по объему информации, 
      хранимой в каждой очереди. Каждый элемент списка представляет собой отдельное 
      сообщение. Сообщения имеют атрибут, называемый <i>типом сообщения</i>. Выборка 
      сообщений из очереди (выполнение примитива <b><font color="#008000">receive</font></b>) 
      может осуществляться тремя способами:</font><br>
      <br>
      <a name="s0902a"></a> 
    <ol >
      <li> 
        <p align="JUSTIFY"> <font face="Times New Roman, Times, serif" size="3"> 
          В порядке FIFO, независимо от типа сообщения. </font> 
      </li>
      <li> 
        <p align="JUSTIFY"> <font face="Times New Roman, Times, serif" size="3"> 
          В порядке FIFO для сообщений конкретного типа. </font> 
      </li>
      <li> 
        <p align="JUSTIFY"> <font face="Times New Roman, Times, serif" size="3"> 
          Первым выбирается сообщение с минимальным типом, не превышающим некоторого 
          заданного значения, пришедшее ранее всех других сообщений с тем же типом.</font> 
      </li>
    </ol>
    <br>
    <p align="JUSTIFY"> <font face="Times New Roman, Times, serif" size="3"> Реализация 
      примитивов <b><font color="#008000">send</font></b> и <b><font color="#008000">receive</font></b> 
      обеспечивает скрытое от пользователя взаимоисключение во время помещения 
      сообщения в очередь или его получении из очереди, а также блокировку процесса 
      при попытке выполнить примитив <b><font color="#008000">receive</font></b> 
      над пустой очередью или очередью, в которой отсутствуют сообщения запрошенного 
      типа, или при попытке выполнить примитив <b><font color="#008000">send</font></b> 
      для очереди, в которой нет свободного места.<br>
      <br>
      Очереди сообщений, как и другие средства System V IPC, позволяют организовывать 
      взаимодействие процессов, не находящихся одновременно в вычислительной системе. 
      </font> <br>
      &nbsp; 
  </LI>
  <LI> 
    <p align="JUSTIFY"> <font  face="Times New Roman, Times, serif" size="3" color="#FF0000"><b> 
      <a name="s0903"></a>Создание очереди сообщений или доступ к уже существующей. 
      Системный вызов msgget(). </b></font> <br>
      <br>
    <p align="JUSTIFY"> <font face="Times New Roman, Times, serif" size="3"> <font face="Times New Roman, Times, serif" size="3">Для 
      создания очереди сообщений, ассоциированной с определенным ключом, или доступа 
      по ключу к уже существующей очереди используется системный вызов <a href="../../man/msgget.htm">msgget()</a>, 
      являющийся аналогом системных вызовов <a href="../../man/shmget.htm">shmget()</a> 
      для разделяемой памяти и <a href="../../man/semget.htm">semget()</a> для 
      массива семафоров, который возвращает значение IPC дескриптора для этой 
      очереди. При этом существуют <a href="../../06/prep/sem6-7.htm#s0605a">те 
      же способы создания и доступа</a>, что и для разделяемой памяти или семафоров.</font> 
      </font><br>
      &nbsp; 
  </LI>
  <LI> 
    <p align="JUSTIFY"><font  face="Times New Roman, Times, serif" size="3" color="#FF0000"><b><a name="s0904"></a> 
      Реализация примитивов send и receive. Системные вызовы msgsnd() и msgrcv(). 
      </b></font> <br>
      <br>
    <p align="JUSTIFY"> <font face="Times New Roman, Times, serif" size="3"> <img border="0" src="../../images/znak.gif" align="left" vspace="5"
	  alt="Nota bene" hspace="10"> Для выполнения примитива<b><font color="#008000"> 
      send</font></b> служит системный вызов <a href="../../man/msgsnd.htm">msgsnd()</a>, 
      копирующий пользовательское сообщение в очередь сообщений, заданную своим 
      IPC дескриптором. При изучении описания этого вызова обратите особое внимание 
      на следующие моменты:<br>
      <br>
      </font> 
    <font face="Times New Roman, Times, serif" size="3"> 
    <ul type="square">
      <li> 
        <p align="JUSTIFY"> <font face="Times New Roman">Тип данных <b><font color="#008000">struct 
          msgbuf</font></b></font><font face="Times New Roman, Times, serif" size="3"> 
          не является типом данных для пользовательских сообщений, а представляет 
          собой лишь шаблон для создания таких типов. Пользователь сам должен 
          создать структуру для своих сообщений, в которой первым полем обязана 
          быть переменная типа<b><font color="#008000"> long</font></b>, содержащая 
          положительное значение типа сообщения. </font> 
      </li>
      <li> 
        <p align="JUSTIFY">В качестве третьего параметра - длины сообщения - указывается 
          не вся длина структуры данных, соответствующей сообщению, а только длина 
          полезной информации, т.&nbsp;е. информации, располагающейся в структуре 
          данных после типа сообщения. Это значение может быть и равным 0 в случае, 
          когда вся полезная информация заключается в самом факте наличия сообщения 
          (сообщение используется как сигнальное средство связи).
      </li>
      <li> 
        <p align="JUSTIFY">На наших занятиях мы, как правило, будем использовать 
          нулевое значение флага системного вызова, которое приводит к блокировке 
          процесса при отсутствии достаточного свободного места в очереди сообщений. 
      </li>
    </ul>
    <br>
    </font> 
    <p align="JUSTIFY"><font face="Times New Roman, Times, serif" size="3"> <img border="0" src="../../images/znak.gif" align="left" vspace="5"
	  alt="Nota bene" hspace="10">Примитив<b><font color="#008000"> receive</font></b> 
      реализуется системным вызовом <a href="../../man/msgrcv.htm">msgrcv()</a>. 
      </font> <font face="Times New Roman, Times, serif" size="3">При изучении 
      описания этого вызова обратите особое внимание на следующие моменты:</font><br>
      <br>
    <ul type="square">
      <li> 
        <p align="JUSTIFY"> <font face="Times New Roman"> Тип данных <b><font color="#008000">struct 
          msgbuf</font></b>, как и для вызова <a href="../../man/msgsnd.htm">msgsnd()</a>, 
          является лишь шаблоном для пользовательского типа данных.</font> 
      </li>
      <li> 
        <p align="JUSTIFY"><font face="Times New Roman"> <a href="#s0902a">Способ 
          выбора сообщения</a> задается нулевым, положительным или отрицательным 
          значением параметра<b><font color="#008000"> type</font></b>. Точное 
          значение типа выбранного сообщения можно определить из соответствующего 
          поля структуры, в которую системный вызов скопирует сообщение. </font> 
      </li>
      <li> 
        <p align="JUSTIFY"><font face="Times New Roman"> Системный вызов возвращает 
          длину только полезной части скопированной информации, т.&nbsp;е. информации, 
          расположенной в структуре после поля типа сообщения.</font> 
      </li>
      <li> 
        <p align="JUSTIFY"> <font face="Times New Roman"> Выбранное сообщение 
          удаляется из очереди сообщений. </font> 
      </li>
      <li> 
        <p align="JUSTIFY"> <font face="Times New Roman"> В качестве параметра 
          <b> <font color="#008000">length</font></b> указывается максимальная 
          длина полезной части информации, которая может быть размещена в структуре, 
          адресованной параметром<b><font color="#008000"> ptr</font></b>. </font> 
      </li>
      <li> 
        <p align="JUSTIFY"> <font face="Times New Roman"> На наших занятиях мы 
          будем, как правило, пользоваться нулевым значением флагов для системного 
          вызова, которое приводит к блокировке процесса в случае отсутствия в 
          очереди сообщений с запрошенным типом и к ошибочной ситуации в случае, 
          когда длина информативной части выбранного сообщения превышает длину, 
          специфицированную в параметре <b><font color="#008000">length</font></b>. 
          </font> 
      </li>
    </ul>
    <br>
    <p align="JUSTIFY"> <font face="Times New Roman">Максимально возможная длина 
      информативной части сообщения в операционной системе Linux составляет 4080 
      байт и может быть уменьшена при генерации системы. Текущее значение максимальной 
      длины можно определить с помощью команды </font><br>
    <p align="center"><font color="#008000"><b><a href="../../man/ipcs.htm">ipcs</a> -l</b></font><br>
      <br>
      &nbsp; 
  </LI>
  <LI> 
    <p align="JUSTIFY"><font  face="Times New Roman, Times, serif" size="3" color="#FF0000"><b><a name="s0905"></a> 
      Удаление очереди сообщений из системы с помощью команды ipcrm или системного 
      вызова msgctl().</b></font> <br>
      <br>
    <p align="JUSTIFY"> 
    <font face="Times New Roman, Times, serif" size="3"> После завершения процессов, 
    использовавших очередь сообщений, она не удаляется из системы автоматически, 
    а продолжает сохраняться в системе вместе со всеми невостребованными сообщениями 
    до тех пор,</font><font face="Times New Roman, Times, serif" size="3"> пока 
    не будет выполнена специальная команда или специальный системный вызов. Для 
    удаления очереди сообщений можно воспользоваться уже знакомой нам командой 
    <a href="../../man/ipcrm.htm">ipcrm</a>, которая в этом случае примет вид: 
    </font><font face="Times New Roman, Times, serif" size="3">
    <p align="center"><b> <font color="#008000"><a href="../../man/ipcrm.htm">ipcrm</a> 
      msg &lt;IPC идентификатор</font></b>&gt;&nbsp;&nbsp;<br>
    </p>
    Для получения IPC идентификатора очереди сообщений примените команду <a href="../../man/ipcs.htm">ipcs</a>. 
    Можно удалить очередь сообщений и с помощью системного вызова <a href="../../man/msgctl.htm">msgctl()</a>. 
    Этот вызов умеет выполнять и другие операции над очередью сообщений, но их 
    рассмотрение лежит вне нашего курса. Если какой-либо процесс находился в состоянии 
    <i> <b>ожидание</b></i> при выполнении системного вызова <a href="../../man/msgrcv.htm">msgrcv()</a> 
    или <a href="../../man/msgsnd.htm">msgsnd()</a> для удаляемой очереди, то 
    он будет разблокирован, и системный вызов констатирует наличие ошибочной ситуации.</font><br>
    &nbsp; </LI>
  <LI> 
    <p align="JUSTIFY"><font  face="Times New Roman, Times, serif" size="3" color="#FF0000"><b><a name="s0906"></a> 
      Прогон примера с однонаправленной передачей текстовой информации </b></font> 
      <br>
      <br>
    <p align="JUSTIFY"> <font face="Times New Roman, Times, serif" size="3"> Для 
      иллюстрации всего вышесказанного давайте рассмотрим простые <a href="../stud/09-1c.htm">программы</a> 
      /ftp/pub/sem9/09-1a.c и /ftp/pub/sem9/stud/09-1b.c. <a href="../stud/09-1ca.htm">Первая 
      из этих программ</a> посылает пять текстовых сообщений с типом 1 и одно 
      сообщение нулевой длины с типом 255 <a href="../stud/09-1cb.htm">второй 
      программе</a>. <a href="../stud/09-1cb.htm">Вторая программа</a> в цикле 
      принимает сообщения любого типа в порядке FIFO и печатает их содержимое 
      до тех пор, пока не получит сообщение с типом 255. Сообщение с типом 255 
      служит для нее сигналом к завершению работы и ликвидации очереди сообщений. 
      Если перед запуском любой из программ очередь сообщений еще отсутствовала 
      в системе, то программа создаст ее. <br>
      <br>
      Обратите внимание на использование сообщения с типом 255 в качестве сигнала 
      прекращения работы второго процесса. Это сообщение имеет нулевую длину, 
      так как его информативность исчерпывается самим фактом наличия сообщения.</font><br>
      &nbsp; 
  </LI>
  <LI> 
    <p align="JUSTIFY"><font  face="Times New Roman, Times, serif" size="3" color="#FF0000"><b><a name="s0907"></a> 
      Модификация предыдущего примера для передачи числовой информации. </b></font> 
      <br>      <br>
	  
    <p align="JUSTIFY"> <font face="Times New Roman, Times, serif" size="3"> <img border="0" src="../../images/znak.gif" align="left" vspace="5"
	  alt="Nota bene" hspace="10">В описании системных вызовов <a href="../../man/msgsnd.htm">msgsnd()</a> 
      и <a href="../../man/msgrcv.htm">msgrcv()</a> говорится о том, что передаваемая 
      информации не обязательно должна представлять собой текст. Мы можем воспользоваться 
      очередями сообщений для передачи данных любого вида. При передаче разнородной 
      информации целесообразно информативную часть объединять внутри сообщения 
      в отдельную структуру: </font><br>
	  <br><font face="Times New Roman, Times, serif" size="3">
    <dir> 
      <dir> 
        <dir> <b><font color="#008000">struct mymsgbuf {</font> </b> 
          <dir><b><font color="#008000"> long mtype;<br>
            struct {</font> </b> 
            <dir><b><font color="#008000"> short sinfo;<br>
              float finfo;</font></b></dir>
            <b><font color="#008000">} info;</font></b></dir>
          <b><font color="#008000">} mybuf; </font></b></dir>
      </dir>
    </dir>
	</font>
    <br>
	    
    <p align="JUSTIFY"> <font face="Times New Roman, Times, serif" size="3"> для 
      правильного вычисления длины информативной части. В некоторых вычислительных 
      системах числовые данные размещаются в памяти с выравниванием на определенные 
      адреса (например, на адреса кратные 4). Поэтому реальный размер памяти, 
      необходимой для размещения нескольких числовых данных, может оказаться больше 
      суммы длин этих данных, т. е. в нашем случае, вообще говоря, <b><font color="#008000">sizeof(info)&gt;=sizeof(short)+sizeof(float)</font></b>. 
      Для полной передачи информативной части сообщения в качестве длины нужно 
      указывать не сумму длин полей, а полную длину структуры. Модифицируйте предыдущие 
      <a href="../stud/09-1c.htm">программы</a> для передачи нетекстовых сообщений.</font><br>
      &nbsp; 
  </LI>
  <LI> 
    <p align="JUSTIFY"><font  face="Times New Roman, Times, serif" size="3" color="#FF0000"><b><a name="s0908"></a> 
      Написание, компиляция и прогон программ для осуществления двусторонней связи 
      через одну очередь сообщений. </b></font> <br>
      <br>
    <p align="JUSTIFY"> <font face="Times New Roman, Times, serif" size="3"> Наличие у сообщений типов позволяет организовать двустороннюю связь 
      между процессами через одну и ту же очередь сообщений. Процесс 1 может посылать 
      процессу 2 сообщения с типом 1, а получать от него сообщения с типом 2. 
      При этом для выборки сообщений в обоих процессах следует пользоваться  
      <a href="#s0902a">вторым способом выбора</a>. Напишите, откомпилируйте и прогоните программы, 
      осуществляющие двустороннюю связь через одну очередь сообщений. </font><br>
      &nbsp; 
  </LI>
  <LI> 
    <p align="JUSTIFY"><font  face="Times New Roman, Times, serif" size="3" color="#FF0000"><b><a name="s0909"></a> 
      Понятие мультиплексирования. Мультиплексирование сообщений. Модель взаимодействия процессов клиент-сервер. Неравноправность клиента 
      и сервера. </b></font> <br>
      <br>
    <p align="JUSTIFY"> <font face="Times New Roman, Times, serif" size="3"> Используя 
      технику из предыдущего примера, мы можем организовать получение сообщений 
      одним процессом от множества других процессов через одну очередь сообщений 
      и отправку им ответов через ту же очередь сообщений, т.е. осуществить <i>мультиплексирование 
      </i>сообщений. Вообще под мультиплексированием информации понимают возможность 
      одновременного обмена информацией с несколькими партнерами. Метод мультиплексирования 
      широко применяется в модели взаимодействия процессов <i>клиент-сервер</i>. 
      В этой модели один из процессов является сервером. Сервер получает запросы 
      от других процессов - клиентов - на выполнение некоторых действий и отправляет 
      им результаты обработки запросов. Наиболее часто модель клиент-сервер используется 
      при разработке сетевых приложений, с которыми мы столкнемся на завершающих 
      семинарах курса. Она изначально предполагает неравноправность взаимодействующих 
      процессов:
	  <br></font><br>
     <ul type=square>	  
<li>	<p align="JUSTIFY"> <font face="Times New Roman, Times, serif" size="3">
	 	 Сервер, как правило, работает постоянно, на всем протяжении жизни приложения, а клиенты могут работать эпизодически.
		  </font></li>
<li>	<p align="JUSTIFY"> <font face="Times New Roman, Times, serif" size="3">
Сервер ждет запроса от клиентов, инициатором же взаимодействия выступает клиент.
		  </font></li>
<li>	
        <p align="JUSTIFY"> <font face="Times New Roman, Times, serif" size="3"> 
          Как правило, клиент обращается к одному серверу за раз, в то время как 
          к серверу могут одновременно поступить запросы от нескольких клиентов. 
          </font>
      </li>
<li>	
        <p align="JUSTIFY"> <font face="Times New Roman, Times, serif" size="3"> 
          Клиент должен знать, как обратиться к серверу (например, какого типа 
          сообщения он воспринимает) перед началом организации запроса к серверу, 
          в то время как сервер может получить недостающую информацию о клиенте 
          из пришедшего запроса. </font>
      </li>
</ul>
<br>
	 
    <p align="JUSTIFY"> <font face="Times New Roman, Times, serif" size="3"> Рассмотрим 
      следующую схему мультиплексирования сообщений через одну очередь сообщений 
      для модели клиент-сервер. Пусть сервер получает из очереди сообщений только 
      сообщения с типом 1. В состав сообщений с типом 1, посылаемых серверу, процессы-клиенты 
      включают значение своих идентификаторов процесса. Приняв сообщение с типом 
      1, сервер анализирует его содержание, выявляет идентификатор процесса, пославшего 
      запрос, и отвечает клиенту, посылая сообщение с типом равным идентификатору 
      запрашивавшего процесса. Процесс-клиент после посылки запроса ожидает ответа 
      в виде сообщения с типом равным своему идентификатору. Поскольку идентификаторы 
      процессов в системе различны, и ни один пользовательский процесс не может 
      иметь PID равный 1, все сообщения могут быть прочитаны только теми процессами, 
      которым они адресованы. Если обработка запроса занимает продолжительное 
      время, сервер может организовывать параллельную обработку запросов, порождая 
      для каждого запроса новый процесс-ребенок или новую нить исполнения. </font></p>
  </LI>
   <LI> 
    <p align="JUSTIFY"><font  face="Times New Roman, Times, serif" size="3" color="#FF0000"><b><a name="s0910"></a> 
      Написание, компиляция и прогон программ клиент и сервер.</b></font> <br>
<br>
    <p align="JUSTIFY"> <font face="Times New Roman, Times, serif" size="3"> 
	Напишите, откомпилируйте и прогоните программы сервера и клиентов для  предложенной схемы мультиплексирования сообщений.
	</font><br>
      &nbsp; 
  </LI>
   <LI> 
    <p align="JUSTIFY"><font  face="Times New Roman, Times, serif" size="3" color="#FF0000"><b><a name="s0911"></a> 
      Использование очередей сообщений для синхронизации работы процессов.</b></font> <br>
      <br>
    <p align="JUSTIFY"> <font face="Times New Roman, Times, serif" size="3"><a href="../../06/ch6.htm#l060403"><img border="0" src="../../images/bookopen.gif" 
    alt="Реализация семафоров через сообщения в лекции" align="right" hspace="10" vspace="1" width="48" height="34"></a>На 
      лекции была доказана эквивалентность очередей сообщения и семафоров в системах, 
      где процессы могут использовать разделяемую память. Там, в частности, было 
      показано, как реализовать семафоры с помощью очередей сообщений. Для этого 
      вводился специальный синхронизирующий процесс-сервер, обслуживающий переменные-счетчики 
      для каждого семафора. Процессы-клиенты для выполнения операции над семафором 
      посылали процессу-серверу запросы на выполнение операции и ожидали ответа 
      для продолжения работы. Теперь мы знаем, как это можно сделать в операционной 
      системе UNIX и как, следовательно, можно использовать очереди сообщений 
      для организации взаимоисключений и взаимной синхронизации процессов.</font> <br>
      <br>
      &nbsp; 
  	
	<font face="Times New Roman, Times, serif" size="2"><b><u>Задача 
      повышенной сложности:</u></b> реализуйте семафоры через очереди сообщений.</font>
	  </LI>
</ol>
      <br>
<P align="center"><a href="../../08/prep/sem8.htm"> Предыдущий семинар</a> | <a href="../../os.html">Программа курса</a> | 
 <a href="../../exams/kr1h.htm"> Следующий семинар</a></P><br>
</BODY>
</HTML>
